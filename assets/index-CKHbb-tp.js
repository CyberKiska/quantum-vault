import{ml_kem1024 as b}from"https://esm.sh/@noble/post-quantum@0.4.1/ml-kem.js";import{hkdf as S}from"https://esm.sh/@noble/hashes@1.8.0/hkdf";import{sha256 as K}from"https://esm.sh/@noble/hashes@1.8.0/sha256";import{sha3_512 as A}from"https://esm.sh/@noble/hashes@1.8.0/sha3";import{split as k,combine as q}from"https://esm.sh/shamir-secret-sharing@0.0.4";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))a(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&a(o)}).observe(document,{childList:!0,subtree:!0});function s(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function a(n){if(n.ep)return;n.ep=!0;const r=s(n);fetch(n.href,r)}})();const L=document.querySelectorAll("button"),$=document.getElementById("privKeyInput"),E=document.getElementById("pubKeyInput"),h=document.getElementById("dataFileInput"),H=document.getElementById("containerToSplitInput"),T=document.getElementById("shardsToCombineInput"),N=document.getElementById("shamirShares"),I=document.getElementById("shamirThreshold"),C=document.getElementById("genKeyBtn"),U=document.getElementById("encBtn"),P=document.getElementById("decBtn"),D=document.getElementById("splitBtn"),O=document.getElementById("combineBtn"),g=document.getElementById("log"),F=e=>Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("");function c(e){g.textContent+=`[${new Date().toLocaleTimeString()}] ${e}
`,g.scrollTop=g.scrollHeight}function l(e){g.innerHTML+=`<span class="error">[${new Date().toLocaleTimeString()}] ERROR: ${e}</span>
`,g.scrollTop=g.scrollHeight}function d(e){L.forEach(t=>t.disabled=e)}function w(e,t){const s=document.createElement("a");s.href=URL.createObjectURL(e),s.download=t,s.style.display="none",document.body.appendChild(s),s.click(),URL.revokeObjectURL(s.href),s.remove()}async function u(e){return new Uint8Array(await e.arrayBuffer())}async function y(e){return F(A(e))}async function v(e,t){const s=S(K,e,t,new Uint8Array(0),32);return crypto.subtle.importKey("raw",s,"AES-GCM",!1,["encrypt","decrypt"])}async function R(e,t){const{cipherText:s,sharedSecret:a}=b.encapsulate(t);if(!s)throw new Error("Encapsulation failed. The returned key is undefined.");const n=crypto.getRandomValues(new Uint8Array(12)),r=crypto.getRandomValues(new Uint8Array(16)),o=await v(a,r),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},o,e),f=new TextEncoder().encode("QGv1"),m=new Uint8Array(4);new DataView(m.buffer).setUint32(0,s.length,!1);const p=new Uint8Array([...f,...m,...s,...n,...r]);return new Blob([p,new Uint8Array(i)],{type:"application/octet-stream"})}async function M(e,t){if(new TextDecoder().decode(e.slice(0,4))!=="QGv1")throw new Error("Invalid file format or file is corrupted.");let a=4;const n=new DataView(e.buffer).getUint32(a,!1);a+=4;const r=e.slice(a,a+n);a+=n;const o=e.slice(a,a+12);a+=12;const i=e.slice(a,a+16);a+=16;const f=e.slice(a),m=b.decapsulate(r,t),p=await v(m,i),B=await crypto.subtle.decrypt({name:"AES-GCM",iv:o},p,f);return new Blob([B])}C.addEventListener("click",async()=>{d(!0);try{c("Generating ML-KEM Kyber 1024 key pair...");const{secretKey:e,publicKey:t}=b.keygen(),s=await y(e),a=await y(t);c(`Private Key: secretKey.qkey (${e.length} B) SHA3-512=${s}`),c(`Public Key: publicKey.qkey (${t.length} B) SHA3-512=${a}`),w(new Blob([e]),"secretKey.qkey"),w(new Blob([t]),"publicKey.qkey"),c("✅ Keys generated and downloaded successfully.")}catch(e){l(e.message)}finally{d(!1)}});U.addEventListener("click",async()=>{if(!E.files[0]){l("Please select a public key (.qkey).");return}if(!h.files.length){l("Please select file(s) to encrypt.");return}d(!0);try{const e=await u(E.files[0]);for(const t of h.files){c(`Encrypting file ${t.name} (${t.size} B)...`);const s=await u(t),a=await y(s);c(`  Source file hash: SHA3-512=${a}`);const n=await R(s,e),r=await u(n),o=await y(r);w(n,`${t.name}.qenc`),c(`✅ File encrypted: ${t.name}.qenc (${n.size} B) SHA3-512=${o}`)}}catch(e){l(e.message)}finally{d(!1),h.value=""}});P.addEventListener("click",async()=>{if(!$.files[0]){l("Please select a private key (.qkey).");return}if(!h.files.length){l("Please select file(s) to decrypt (.qenc).");return}d(!0);try{const e=await u($.files[0]);for(const t of h.files){if(!t.name.toLowerCase().endsWith(".qenc")){c(`Skipping file ${t.name} as it is not a .qenc container.`);continue}c(`Decrypting file ${t.name} (${t.size} B)...`);const s=await u(t),a=await y(s);c(`  Container hash: SHA3-512=${a}`);const n=await M(s,e),r=await u(n),o=await y(r),i=t.name.replace(/\.qenc$/i,"");w(n,i),c(`✅ File decrypted: ${i} (${n.size} B) SHA3-512=${o}`)}}catch(e){l(`Failed to decrypt file. Check if the key is correct. Details: ${e.message}`)}finally{d(!1),h.value=""}});D.addEventListener("click",async()=>{const e=H.files[0];if(!e){l("Please select a .qenc container to split.");return}d(!0);try{const t=parseInt(N.value,10),s=parseInt(I.value,10);if(isNaN(t)||isNaN(s)||s>t||s<2||t<2)throw new Error("Invalid N and T parameters. Ensure T >= 2 and N >= T.");c(`Splitting container ${e.name} into ${t} parts with a threshold of ${s}...`);const a=await u(e),n=await y(a);c(`  Container hash: SHA3-512=${n}`);const r=await k(a,t,s),o=Object.values(r),i=e.name.replace(/\.qenc$/i,"");o.forEach((f,m)=>{const p=new Blob([f]),B=`${i}-${m+1}.qshard`;w(p,B),c(`  ✂️ Shard created: ${B} (${p.size} B)`)}),c("✅ Splitting process completed successfully.")}catch(t){l(t.message)}finally{d(!1)}});O.addEventListener("click",async()=>{const e=T.files;if(!e.length){l("Please select .qshard files to combine.");return}d(!0);try{const t=parseInt(I.value,10);if(e.length<t)throw new Error(`Not enough shards to reconstruct. A minimum of ${t} is required, but ${e.length} were selected.`);c(`Combining container from ${e.length} shards...`);const s=await Promise.all([...e].map(f=>u(f))),a=await q(s),n=new Blob([a]),r=await y(a),i=`${e[0].name.replace(/-\d+\.qshard$/i,"")}.qenc`;w(n,i),c(`✅ Container combined: ${i} (${n.size} B) SHA3-512=${r}`),c("  Compare this hash with the original container hash to verify integrity.")}catch(t){l(`Failed to combine container. Ensure the shards are from the same set and meet the threshold. Details: ${t.message}`)}finally{d(!1)}});

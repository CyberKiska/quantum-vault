(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(o){if(o.ep)return;o.ep=!0;const r=n(o);fetch(o.href,r)}})();const ze=BigInt(2**32-1),lt=BigInt(32);function Yt(e,t=!1){return t?{h:Number(e&ze),l:Number(e>>lt&ze)}:{h:Number(e>>lt&ze)|0,l:Number(e&ze)|0}}function Wt(e,t=!1){const n=e.length;let s=new Uint32Array(n),o=new Uint32Array(n);for(let r=0;r<n;r++){const{h:i,l:a}=Yt(e[r],t);[s[r],o[r]]=[i,a]}return[s,o]}const Zt=(e,t,n)=>e<<n|t>>>32-n,en=(e,t,n)=>t<<n|e>>>32-n,tn=(e,t,n)=>t<<n-32|e>>>64-n,nn=(e,t,n)=>e<<n-32|t>>>64-n;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function sn(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function dt(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >0, got ${e}`)}}function X(e,t,n=""){const s=sn(e),o=e?.length,r=t!==void 0;if(!s||r&&o!==t){const i=n&&`"${n}" `,a=r?` of length ${t}`:"",c=s?`length=${o}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+a+", got "+c)}return e}function ut(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function on(e,t){X(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function tt(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Lt(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const rn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function an(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function cn(e){for(let t=0;t<e.length;t++)e[t]=an(e[t]);return e}const ft=rn?e=>e:cn;function ln(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function dn(e,t=""){return typeof e=="string"?ln(e):X(e,void 0,t)}function xt(e,t={}){const n=(o,r)=>e(r).update(o).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=o=>e(o),Object.assign(n,t),Object.freeze(n)}function un(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const Ge=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])}),fn=BigInt(0),$e=BigInt(1),hn=BigInt(2),yn=BigInt(7),pn=BigInt(256),mn=BigInt(113),At=[],Mt=[],Bt=[];for(let e=0,t=$e,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],At.push(2*(5*s+n)),Mt.push((e+1)*(e+2)/2%64);let o=fn;for(let r=0;r<7;r++)t=(t<<$e^(t>>yn)*mn)%pn,t&hn&&(o^=$e<<($e<<BigInt(r))-$e);Bt.push(o)}const Ut=Wt(Bt,!0),gn=Ut[0],wn=Ut[1],ht=(e,t,n)=>n>32?tn(e,t,n):Zt(e,t,n),yt=(e,t,n)=>n>32?nn(e,t,n):en(e,t,n);function bn(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=n[c],l=n[c+1],f=ht(d,l,1)^n[a],w=yt(d,l,1)^n[a+1];for(let m=0;m<50;m+=10)e[i+m]^=f,e[i+m+1]^=w}let o=e[2],r=e[3];for(let i=0;i<24;i++){const a=Mt[i],c=ht(o,r,a),d=yt(o,r,a),l=At[i];o=e[l],r=e[l+1],e[l]=c,e[l+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)n[a]=e[i+a];for(let a=0;a<10;a++)e[i+a]^=~n[(a+2)%10]&n[(a+4)%10]}e[0]^=gn[s],e[1]^=wn[s]}Lt(n)}class He{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,s,o=!1,r=24){if(this.blockLen=t,this.suffix=n,this.outputLen=s,this.enableXOF=o,this.rounds=r,dt(s,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=tt(this.state)}clone(){return this._cloneInto()}keccak(){ft(this.state32),bn(this.state32,this.rounds),ft(this.state32),this.posOut=0,this.pos=0}update(t){ut(this),X(t);const{blockLen:n,state:s}=this,o=t.length;for(let r=0;r<o;){const i=Math.min(n-this.pos,o-r);for(let a=0;a<i;a++)s[this.pos++]^=t[r++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:s,blockLen:o}=this;t[s]^=n,(n&128)!==0&&s===o-1&&this.keccak(),t[o-1]^=128,this.keccak()}writeInto(t){ut(this,!1),X(t),this.finish();const n=this.state,{blockLen:s}=this;for(let o=0,r=t.length;o<r;){this.posOut>=s&&this.keccak();const i=Math.min(s-this.posOut,r-o);t.set(n.subarray(this.posOut,this.posOut+i),o),this.posOut+=i,o+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return dt(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(on(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Lt(this.state)}_cloneInto(t){const{blockLen:n,suffix:s,outputLen:o,rounds:r,enableXOF:i}=this;return t||=new He(n,s,o,i,r),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=s,t.outputLen=o,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Ct=(e,t,n,s={})=>xt(()=>new He(t,e,n),s),En=Ct(6,136,32,Ge(8)),Ie=Ct(6,72,64,Ge(10)),$t=(e,t,n,s={})=>xt((o={})=>new He(t,e,o.dkLen===void 0?n:o.dkLen,!0),s),kn=$t(31,168,16,Ge(11)),Tt=$t(31,136,32,Ge(12));function nt(e){if(!Number.isSafeInteger(e)||e<0||e>4294967295)throw new Error("wrong u32 integer:"+e);return e}function Kt(e){return nt(e),(e&e-1)===0&&e!==0}function Nt(e,t){nt(e);let n=0;for(let s=0;s<t;s++,e>>>=1)n=n<<1|e&1;return n}function Ft(e){return nt(e),31-Math.clz32(e)}function pt(e){const t=e.length;if(t<2||!Kt(t))throw new Error("n must be a power of 2 and greater than 1. Got "+t);const n=Ft(t);for(let s=0;s<t;s++){const o=Nt(s,n);if(s<o){const r=e[s];e[s]=e[o],e[o]=r}}return e}const mt=(e,t)=>{const{N:n,roots:s,dit:o,invertButterflies:r=!1,skipStages:i=0,brp:a=!0}=t,c=Ft(n);if(!Kt(n))throw new Error("FFT: Polynomial size should be power of two");const d=o!==r;return l=>{if(l.length!==n)throw new Error("FFT: wrong Polynomial length");o&&a&&pt(l);for(let f=0,w=1;f<c-i;f++){const m=o?f+1+i:c-f,p=1<<m,S=p>>1,$=n>>m;for(let y=0;y<n;y+=p)for(let g=0,x=w++;g<S;g++){const C=r?o?n-x:x:g*$,I=y+g,u=y+g+S,h=s[C],L=l[u],b=l[I];if(d){const B=e.mul(L,h);l[I]=e.add(b,B),l[u]=e.sub(b,B)}else r?(l[I]=e.add(L,b),l[u]=e.mul(e.sub(L,b),h)):(l[I]=e.add(b,L),l[u]=e.mul(e.sub(b,L),h))}}return!o&&a&&pt(l),l}};/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */const gt=un;function Je(e,t){if(e.length!==t.length)return!1;let n=0;for(let s=0;s<e.length;s++)n|=e[s]^t[s];return n===0}function vn(e){return Uint8Array.from(e)}function Ve(e,...t){const n=o=>typeof o=="number"?o:o.bytesLen,s=t.reduce((o,r)=>o+n(r),0);return{bytesLen:s,encode:o=>{const r=new Uint8Array(s);for(let i=0,a=0;i<t.length;i++){const c=t[i],d=n(c),l=typeof c=="number"?o[i]:c.encode(o[i]);X(l,d,e),r.set(l,a),typeof c!="number"&&l.fill(0),a+=d}return r},decode:o=>{X(o,s,e);const r=[];for(const i of t){const a=n(i),c=o.subarray(0,a);r.push(typeof i=="number"?c:i.decode(c)),o=o.subarray(a)}return r}}}function Ye(e,t){const n=t*e.bytesLen;return{bytesLen:n,encode:s=>{if(s.length!==t)throw new Error(`vecCoder.encode: wrong length=${s.length}. Expected: ${t}`);const o=new Uint8Array(n);for(let r=0,i=0;r<s.length;r++){const a=e.encode(s[r]);o.set(a,i),a.fill(0),i+=a.length}return o},decode:s=>{X(s,n);const o=[];for(let r=0;r<s.length;r+=e.bytesLen)o.push(e.decode(s.subarray(r,r+e.bytesLen)));return o}}}function fe(...e){for(const t of e)if(Array.isArray(t))for(const n of t)n.fill(0);else t.fill(0)}function wt(e){return(1<<e)-1}/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */const Sn=e=>{const{newPoly:t,N:n,Q:s,F:o,ROOT_OF_UNITY:r,brvBits:i}=e,a=(y,g=s)=>{const x=y%g|0;return(x>=0?x|0:g+x|0)|0},c=(y,g=s)=>{const x=a(y,g)|0;return(x>g>>1?x-g|0:x)|0};function d(){const y=t(n);for(let g=0;g<n;g++){const x=Nt(g,i),C=BigInt(r)**BigInt(x)%BigInt(s);y[g]=Number(C)|0}return y}const l=d(),f={add:(y,g)=>a((y|0)+(g|0))|0,sub:(y,g)=>a((y|0)-(g|0))|0,mul:(y,g)=>a((y|0)*(g|0))|0,inv:y=>{throw new Error("not implemented")}},w={N:n,roots:l,invertButterflies:!0,skipStages:1,brp:!1},m=mt(f,{dit:!1,...w}),p=mt(f,{dit:!0,...w});return{mod:a,smod:c,nttZetas:l,NTT:{encode:y=>m(y),decode:y=>{p(y);for(let g=0;g<y.length;g++)y[g]=a(o*y[g]);return y}},bitsCoder:(y,g)=>{const x=wt(y),C=y*(n/8);return{bytesLen:C,encode:I=>{const u=new Uint8Array(C);for(let h=0,L=0,b=0,B=0;h<I.length;h++)for(L|=(g.encode(I[h])&x)<<b,b+=y;b>=8;b-=8,L>>=8)u[B++]=L&wt(b);return u},decode:I=>{const u=t(n);for(let h=0,L=0,b=0,B=0;h<I.length;h++)for(L|=I[h]<<b,b+=8;b>=y;b-=y,L>>=y)u[B++]=g.decode(L&x);return u}}}}},In=e=>(t,n)=>{n||(n=e.blockLen);const s=new Uint8Array(t.length+2);s.set(t);const o=t.length,r=new Uint8Array(n);let i=e.create({}),a=0,c=0;return{stats:()=>({calls:a,xofs:c}),get:(d,l)=>(s[o+0]=d,s[o+1]=l,i.destroy(),i=e.create({}).update(s),a++,()=>(c++,i.xofInto(r))),clean:()=>{i.destroy(),fe(r,s)}}},Ln=In(kn);/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */const Z=256,xe=3329,xn=3303,An=17,{mod:Oe,nttZetas:Mn,NTT:ve,bitsCoder:Bn}=Sn({N:Z,Q:xe,F:xn,ROOT_OF_UNITY:An,newPoly:e=>new Uint16Array(e),brvBits:7}),Un={1024:{N:Z,Q:xe,K:4,ETA1:2,ETA2:2,du:11,dv:5,RBGstrength:256}},Cn=e=>{if(e>=12)return{encode:n=>n,decode:n=>n};const t=2**(e-1);return{encode:n=>((n<<e)+xe/2)/xe,decode:n=>n*xe+t>>>e}},Te=e=>Bn(e,Cn(e));function Se(e,t){for(let n=0;n<Z;n++)e[n]=Oe(e[n]+t[n])}function $n(e,t){for(let n=0;n<Z;n++)e[n]=Oe(e[n]-t[n])}function Tn(e,t,n,s,o){const r=Oe(t*s*o+e*n),i=Oe(e*s+t*n);return{c0:r,c1:i}}function Re(e,t){for(let n=0;n<Z/2;n++){let s=Mn[64+(n>>1)];n&1&&(s=-s);const{c0:o,c1:r}=Tn(e[2*n+0],e[2*n+1],t[2*n+0],t[2*n+1],s);e[2*n+0]=o,e[2*n+1]=r}return e}function bt(e){const t=new Uint16Array(Z);for(let n=0;n<Z;){const s=e();if(s.length%3)throw new Error("SampleNTT: unaligned block");for(let o=0;n<Z&&o+3<=s.length;o+=3){const r=(s[o+0]>>0|s[o+1]<<8)&4095,i=(s[o+1]>>4|s[o+2]<<4)&4095;r<xe&&(t[n++]=r),n<Z&&i<xe&&(t[n++]=i)}}return t}function Ke(e,t,n,s){const o=e(s*Z/4,t,n),r=new Uint16Array(Z),i=tt(o);let a=0;for(let c=0,d=0,l=0,f=0;c<i.length;c++){let w=i[c];for(let m=0;m<32;m++)l+=w&1,w>>=1,a+=1,a===s?(f=l,l=0):a===2*s&&(r[d++]=Oe(f-l),l=0,a=0)}if(a)throw new Error(`sampleCBD: leftover bits: ${a}`);return r}const Kn=e=>{const{K:t,PRF:n,XOF:s,HASH512:o,ETA1:r,ETA2:i,du:a,dv:c}=e,d=Te(1),l=Te(c),f=Te(a),w=Ve("publicKey",Ye(Te(12),t),32),m=Ye(Te(12),t),p=Ve("ciphertext",Ye(f,t),l),S=Ve("seed",32,32);return{secretCoder:m,lengths:{secretKey:m.bytesLen,publicKey:w.bytesLen,cipherText:p.bytesLen},keygen:$=>{X($,32,"seed");const y=new Uint8Array(33);y.set($),y[32]=t;const g=o(y),[x,C]=S.decode(g),I=[],u=[];for(let b=0;b<t;b++)I.push(ve.encode(Ke(n,C,b,r)));const h=s(x);for(let b=0;b<t;b++){const B=ve.encode(Ke(n,C,t+b,r));for(let v=0;v<t;v++){const N=bt(h.get(v,b));Se(B,Re(N,I[v]))}u.push(B)}h.clean();const L={publicKey:w.encode([u,x]),secretKey:m.encode(I)};return fe(x,C,I,u,y,g),L},encrypt:($,y,g)=>{const[x,C]=w.decode($),I=[];for(let v=0;v<t;v++)I.push(ve.encode(Ke(n,g,v,r)));const u=s(C),h=new Uint16Array(Z),L=[];for(let v=0;v<t;v++){const N=Ke(n,g,t+v,i),F=new Uint16Array(Z);for(let H=0;H<t;H++){const z=bt(u.get(v,H));Se(F,Re(z,I[H]))}Se(N,ve.decode(F)),L.push(N),Se(h,Re(x[v],I[v])),fe(F)}u.clean();const b=Ke(n,g,2*t,i);Se(b,ve.decode(h));const B=d.decode(y);return Se(B,b),fe(x,I,h,b),p.encode([L,B])},decrypt:($,y)=>{const[g,x]=p.decode($),C=m.decode(y),I=new Uint16Array(Z);for(let u=0;u<t;u++)Se(I,Re(C[u],ve.encode(g[u])));return $n(x,ve.decode(I)),fe(I,C,g),d.encode(x)}}};function Nn(e){const t=Kn(e),{HASH256:n,HASH512:s,KDF:o}=e,{secretCoder:r,lengths:i}=t,a=Ve("secretKey",i.secretKey,i.publicKey,32,32),c=32,d=64;return{info:{type:"ml-kem"},lengths:{...i,seed:64,msg:c,msgRand:c,secretKey:a.bytesLen},keygen:(l=gt(d))=>{X(l,d,"seed");const{publicKey:f,secretKey:w}=t.keygen(l.subarray(0,32)),m=n(f),p=a.encode([w,f,m,l.subarray(32)]);return fe(w,m),{publicKey:f,secretKey:p}},getPublicKey:l=>{const[f,w,m,p]=a.decode(l);return Uint8Array.from(w)},encapsulate:(l,f=gt(c))=>{X(l,i.publicKey,"publicKey"),X(f,c,"message");const w=l.subarray(0,384*e.K),m=r.encode(r.decode(vn(w)));if(!Je(m,w))throw fe(m),new Error("ML-KEM.encapsulate: wrong publicKey modulus");fe(m);const p=s.create().update(f).update(n(l)).digest(),S=t.encrypt(l,f,p.subarray(32,64));return fe(p.subarray(32)),{cipherText:S,sharedSecret:p.subarray(0,32)}},decapsulate:(l,f)=>{X(f,a.bytesLen,"secretKey"),X(l,i.cipherText,"cipherText");const w=a.bytesLen-96,m=w+32,p=n(f.subarray(w/2,m));if(!Je(p,f.subarray(m,m+32)))throw new Error("invalid secretKey: hash check failed");const[S,$,y,g]=a.decode(f),x=t.decrypt(l,S),C=s.create().update(x).update(y).digest(),I=C.subarray(0,32),u=t.encrypt($,x,C.subarray(32,64)),h=Je(l,u),L=o.create({dkLen:32}).update(g).update(l).digest();return fe(x,u,h?L:I),h?I:L}}}function Fn(e,t,n){return Tt.create({dkLen:e}).update(t).update(new Uint8Array([n])).digest()}const On={HASH256:En,HASH512:Ie,KDF:Tt,XOF:Ln,PRF:Fn},st=Nn({...On,...Un[1024]}),be=BigInt(8),Qe=BigInt(255);function Ne(e){e=BigInt(e);const t=[Number(e&Qe)];for(e>>=be;e>0;e>>=be)t.unshift(Number(e&Qe));return t.unshift(t.length),new Uint8Array(t)}function Pn(e){e=BigInt(e);const t=[Number(e&Qe)];for(e>>=be;e>0;e>>=be)t.unshift(Number(e&Qe));return t.push(t.length),new Uint8Array(t)}function Hn(e,t){return e.dkLen===void 0?t:e.dkLen}const qn=(e,t="")=>e===void 0?Pt:(X(e,void 0,t),e),Ot=(e,t)=>new Uint8Array((t-e%t)%t);function Dn(e,t={}){if(!t||t.personalization===void 0&&t.NISTfn===void 0)return e;const n=Ne(e.blockLen),s=t.NISTfn===void 0?Pt:dn(t.NISTfn),o=Ne(be*BigInt(s.length)),r=qn(t.personalization,"personalization"),i=Ne(be*BigInt(r.length));if(!s.length&&!r.length)return e;e.suffix=4,e.update(n).update(o).update(s).update(i).update(r);let a=n.length+o.length+s.length+i.length+r.length;return e.update(Ot(a,e.blockLen)),e}class zn extends He{constructor(t,n,s,o,r={}){super(t,31,n,s),Dn(this,{NISTfn:"KMAC",personalization:r.personalization}),X(o,void 0,"key");const i=Ne(this.blockLen),a=Ne(be*BigInt(o.length));this.update(i).update(a).update(o);const c=i.length+a.length+o.length;this.update(Ot(c,this.blockLen))}finish(){this.finished||this.update(Pn(this.enableXOF?0:be*BigInt(this.outputLen))),super.finish()}_cloneInto(t){return t||(t=Object.create(Object.getPrototypeOf(this),{}),t.state=this.state.slice(),t.blockLen=this.blockLen,t.state32=tt(t.state)),super._cloneInto(t)}clone(){return this._cloneInto()}}function Rn(e,t,n=!1){const s=(o,r,i)=>s.create(o,i).update(r).digest();return s.create=(o,r={})=>new zn(e,Hn(r,t),n,o,r),s}const Ae=Rn(136,32),Pt=Uint8Array.of(),he={minEvents:100,mixOsEveryNEvents:32,maxCollectionMs:3e4,directionBuckets:8,maxTimeDeltaMs:1e3,seedLength:64},G=he.seedLength;function _n(){return crypto.getRandomValues(new Uint8Array(G))}function Vn(e,t,n,s){const r=Math.atan2(t,e)+Math.PI,i=Math.floor(r/(2*Math.PI)*he.directionBuckets)%he.directionBuckets,a=Math.min(255,Math.floor(Math.hypot(e,t))),c=Math.min(he.maxTimeDeltaMs,Math.max(0,n)),d=new Uint8Array(6);return d[0]=1,d[1]=i&255,d[2]=a&255,d[3]=c&255,d[4]=c>>8&255,d[5]=s&255,d}function Qn(e,t,n,s,o){const r=t+n+(o?1:0)&255,i=Math.min(he.maxTimeDeltaMs,Math.max(0,s)),a=new Uint8Array(5);return a[0]=2,a[1]=r,a[2]=i&255,a[3]=i>>8&255,a[4]=n&255,a}function jn(e,t,n){const s=Math.floor(e/100)&255,o=Math.floor(t/100)&255,r=Math.min(he.maxTimeDeltaMs,Math.max(0,n)),i=new Uint8Array(5);return i[0]=3,i[1]=s,i[2]=o,i[3]=r&255,i[4]=r>>8&255,i}class Ht{constructor(){this.events=[],this.isCollecting=!1,this.startTime=0,this.listeners=[],this.entropyBuffer=new Uint8Array(0),this.entropyState=crypto.getRandomValues(new Uint8Array(64)),this.lastEventTime=0,this.screenInfo=null,this.eventCount=0,this.processingQueue=[],this.isProcessing=!1,this.lastMouseX=0,this.lastMouseY=0,this.mouseInitialized=!1}async startCollection(){if(this.isCollecting)throw new Error("Entropy collection already in progress");return new Promise((t,n)=>{this.isCollecting=!0,this.startTime=performance.now(),this.lastEventTime=this.startTime,this.events=[],this.entropyBuffer=new Uint8Array(0),this.screenInfo={width:window.innerWidth,height:window.innerHeight,screenX:window.screenX,screenY:window.screenY,colorDepth:window.screen.colorDepth,pixelDepth:window.screen.pixelDepth},this.setupEventListeners();const s=setTimeout(()=>{console.log("⚠️ Entropy collection timeout reached, generating final seed..."),this.stopCollection();const r=this.generateFinalSeed();console.log(`Timeout final seed length: ${r.length} bytes`),t(r)},he.maxCollectionMs),o=()=>{this.events.length>=he.minEvents?(clearTimeout(s),this.stopCollection(),t(this.generateFinalSeed())):this.isCollecting&&setTimeout(o,100)};setTimeout(o,100)})}stopCollection(){this.isCollecting=!1,this.removeEventListeners()}setupEventListeners(){const t=r=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime;if(!this.mouseInitialized){this.lastMouseX=r.clientX,this.lastMouseY=r.clientY,this.mouseInitialized=!0,this.lastEventTime=i;return}const c=r.clientX-this.lastMouseX,d=r.clientY-this.lastMouseY;if(c===0&&d===0)return;const l=Vn(c,d,a,r.buttons);this.lastMouseX=r.clientX,this.lastMouseY=r.clientY,this.lastEventTime=i,this.processEventAsync(l),this.events.push({type:"mouse",timestamp:i})},n=r=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime,c=Qn(r.key,r.keyCode,r.location,a,r.repeat);this.lastEventTime=i,this.processEventAsync(c),this.events.push({type:"key",timestamp:i})},s=()=>{if(!this.isCollecting)return;const r=performance.now(),i=r-this.lastEventTime,a=jn(window.innerWidth,window.innerHeight,i);this.lastEventTime=r,this.processEventAsync(a),this.events.push({type:"window",timestamp:r})},o=r=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime,c=r.touches[0];if(c){const d=Math.floor(c.clientX/50)&255,l=Math.floor(c.clientY/50)&255,f=new Uint8Array(6);f[0]=4,f[1]=d,f[2]=l,f[3]=Math.min(255,Math.floor(c.force*255))&255,f[4]=a&255,f[5]=a>>8&255,this.lastEventTime=i,this.processEventAsync(f),this.events.push({type:"touch",timestamp:i})}};document.addEventListener("mousemove",t,{passive:!0}),document.addEventListener("keydown",n,{passive:!0}),document.addEventListener("keyup",n,{passive:!0}),window.addEventListener("resize",s,{passive:!0}),window.addEventListener("focus",s,{passive:!0}),window.addEventListener("blur",s,{passive:!0}),document.addEventListener("touchmove",o,{passive:!0}),this.listeners=[{element:document,event:"mousemove",handler:t},{element:document,event:"keydown",handler:n},{element:document,event:"keyup",handler:n},{element:window,event:"resize",handler:s},{element:window,event:"focus",handler:s},{element:window,event:"blur",handler:s},{element:document,event:"touchmove",handler:o}]}removeEventListeners(){this.listeners.forEach(({element:t,event:n,handler:s})=>{t.removeEventListener(n,s)}),this.listeners=[]}processEventAsync(t){this.processingQueue.push(t),this.isProcessing||(this.isProcessing=!0,setTimeout(()=>this.processQueue(),0))}async processQueue(){for(;this.processingQueue.length>0;){const t=this.processingQueue.shift();await this.processEventSummary(t),this.processingQueue.length>0&&await new Promise(n=>setTimeout(n,0))}this.isProcessing=!1}async processEventSummary(t){if(this.eventCount++,this.eventCount%he.mixOsEveryNEvents===0){const i=crypto.getRandomValues(new Uint8Array(32)),a=new Uint8Array(this.entropyState.length+i.length);a.set(this.entropyState,0),a.set(i,this.entropyState.length),this.entropyState=Ie(a)}const n=crypto.getRandomValues(new Uint8Array(16)),s=new Uint8Array(t.length+n.length);s.set(t,0),s.set(n,t.length);const o=Ie(s),r=new Uint8Array(this.entropyState.length+o.length);r.set(this.entropyState,0),r.set(o,this.entropyState.length),this.entropyState=Ie(r),t.fill(0)}generateFinalSeed(){this.processingQueue.length>0&&(this.processingQueue.forEach(c=>{this.processEventSummary(c)}),this.processingQueue=[]);const t=crypto.getRandomValues(new Uint8Array(32)),n=new Uint8Array(this.entropyState.length+t.length);n.set(this.entropyState,0),n.set(t,this.entropyState.length),this.entropyState=Ie(n);const s=new Uint8Array(4);s[0]=0;const o=Ae(this.entropyState,s,void 0,{customization:"quantum-vault:final-seed:v1"});s[0]=1;const r=Ae(this.entropyState,s,void 0,{customization:"quantum-vault:final-seed:v1"}),i=new Uint8Array(G);i.set(o,0),i.set(r,32);const a=new Uint8Array(this.entropyState.length+i.length);return a.set(this.entropyState,0),a.set(i,this.entropyState.length),this.entropyState=Ie(a),i}getProgress(){const t=this.events.length,n=he.minEvents,s=Math.min(100,Math.round(t/n*100)),o=this.estimateEntropyBits();return{collected:t,required:n,percentage:s,queueSize:this.processingQueue.length,estimatedEntropyBits:o,isCollecting:this.isCollecting}}estimateEntropyBits(){if(this.events.length===0)return 0;const t={mouse:0,key:0,window:0,touch:0};this.events.forEach(i=>{i.type in t&&t[i.type]++});const n=this.events.length;let s=0;Object.values(t).forEach(i=>{if(i>0){const a=i/n;s-=a*Math.log2(a)}});const o=this.estimateTimingEntropy(),r=(s+o)*this.events.length*.1;return Math.min(r,512)}estimateTimingEntropy(){if(this.events.length<2)return 0;const t=[];for(let i=1;i<this.events.length;i++){const a=this.events[i].timestamp-this.events[i-1].timestamp;t.push(a)}const n=50,s=new Map;t.forEach(i=>{const a=Math.floor(i/n);s.set(a,(s.get(a)||0)+1)});let o=0;const r=t.length;return s.forEach(i=>{const a=i/r;o-=a*Math.log2(a)}),o}}function Gn(e,t=new Uint8Array(0)){if(e.length!==G)throw new Error(`Base seed must be ${G} bytes`);if(t.length===0)return e;const n=Ae(e,t,void 0,{customization:"quantum-vault:entropy-mix:v1"}),s=new Uint8Array(G);s.set(n,0);const o=crypto.getRandomValues(new Uint8Array(32));if(s.set(o,32),s.length===G)return s;if(s.length<G){const r=new Uint8Array(G);r.set(s,0);const i=crypto.getRandomValues(new Uint8Array(G-s.length));return r.set(i,s.length),r}else return s.slice(0,G)}async function Xn(e=!1){const t=_n();if(!e)return{seed:t,hasUserEntropy:!1};try{const s=await new Ht().startCollection();console.log(`Entropy collected: ${s.length} bytes`);const o=Gn(t,s);return o.length!==G&&console.warn(`Mixed seed length mismatch: ${o.length}, expected ${G}`),{seed:o,hasUserEntropy:s.length>0}}catch(n){return console.warn("User entropy collection failed, using secure random seed:",n.message),console.log(`Fallback seed length: ${t.length} bytes (expected: ${G})`),{seed:t,hasUserEntropy:!1}}}function Jn(e){if(!(e instanceof Uint8Array))throw new Error("Seed must be Uint8Array");if(e.length!==G)throw new Error(`Seed must be exactly ${G} bytes`)}const Yn=e=>Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("");function Pe(e){if(e instanceof Uint8Array)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("Expected ArrayBuffer or Uint8Array")}function ot(e){const t=typeof e=="string"?e:String(e||"");return t.length<12?t:`${t.slice(0,6)}...${t.slice(-6)}`}async function ne(e){return new Uint8Array(await e.arrayBuffer())}function ce(e,t){const n=document.createElement("a");n.href=URL.createObjectURL(e),n.download=t,n.style.display="none",document.body.appendChild(n),n.click(),URL.revokeObjectURL(n.href),n.remove()}function W(e){document.querySelectorAll("button").forEach(t=>{t.disabled=e})}function qt(){return new Date().toLocaleTimeString()}function Wn(){return new Date().toISOString().slice(0,19).replace(/:/g,"-")}function Zn(e,t){return!(t<2||e<=t||(e-t)%2!==0||e<5)}function es(e,t){const n=e-t;return t+n/2}async function ts(e={}){const{collectUserEntropy:t=!1,customSeed:n=null}=e;let s,o;if(n)Jn(n),s=n,o={hasUserEntropy:!1,source:"custom"};else{const i=await Xn(t);s=i.seed,o={hasUserEntropy:i.hasUserEntropy,source:i.hasUserEntropy?"mixed":"secure-random"}}const r=st.keygen(s);return s.fill(0),{publicKey:Pe(r.publicKey),secretKey:Pe(r.secretKey),seedInfo:o}}async function ns(e){const t=await st.encapsulate(e),n=t.cipherText||t.ciphertext||t.ct,s=t.sharedSecret||t.ss;if(!n||!s)throw new Error("KEM encapsulation failed: result is missing required fields.");return{encapsulatedKey:Pe(n),sharedSecret:Pe(s)}}async function ss(e,t){const n=await st.decapsulate(e,t),s=Pe(n);if(!s||s.length===0)throw new Error("KEM decapsulation failed. The key may be incorrect or the ciphertext corrupted.");return s}const ie=new TextEncoder().encode("QVv1"),os=38,Me=8*1024*1024,Dt="QuantumVault v1.3.1",je=12;async function zt(e,t,n,s){const o=new Uint8Array(t.length+n.length);o.set(t,0),o.set(n,t.length);const a=Ae(e,o,32,{customization:s||Dt}),c=Ae(a,new Uint8Array([1]),32,{customization:"quantum-vault:kenc:v1"}),d=Ae(a,new Uint8Array([2]),32,{customization:"quantum-vault:kiv:v1"}),l=await crypto.subtle.importKey("raw",c.buffer,{name:"AES-GCM"},!1,["encrypt","decrypt"]);return{Kraw:a,Kenc:c,Kiv:d,aesKey:l}}function Rt(e,t,n){const s=new Uint8Array(e.length+8);s.set(e,0);const o=new DataView(s.buffer);return o.setUint32(s.length-8,t,!1),o.setUint32(s.length-4,n,!1),s}function _t(e,t,n,s){const o=new Uint8Array(4);new DataView(o.buffer).setUint32(0,n,!1);const r=new Uint8Array(t.length+o.length);return r.set(t,0),r.set(o,t.length),Ae(e,r,16,{customization:s||"quantum-vault:chunk-iv:v1"}).slice(0,12)}async function Et(e,t,n,s){if(n.length!==je)throw new Error(`IV must be ${je} bytes for AES-GCM`);const o=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,additionalData:s,tagLength:128},e,t);return new Uint8Array(o)}async function kt(e,t,n,s){if(n.length!==je)throw new Error(`IV must be ${je} bytes for AES-GCM`);const o=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,additionalData:s,tagLength:128},e,t);return new Uint8Array(o)}function rs(e){return e>Me}function Vt(e){return Math.ceil(e/Me)}function Qt(...e){e.forEach(t=>{t instanceof Uint8Array&&t.fill(0)})}async function jt(e={}){return await ts(e)}async function D(e){return Yn(Ie(e))}async function Gt(e,t,n){const{encapsulatedKey:s,sharedSecret:o}=await ns(t),r=crypto.getRandomValues(new Uint8Array(12)),i=crypto.getRandomValues(new Uint8Array(16)),a=rs(e.length),c=a?Vt(e.length):1,d={kdf:"quantum-vault:kdf:v1",iv:"quantum-vault:chunk-iv:v1"},l={KEM:"ML-KEM-1024",KDF:"KMAC256",AEAD:"AES-256-GCM",aead_mode:a?"per-chunk-aead":"single-container-aead",iv_strategy:a?"kmac-derive-v1":"single-iv",fmt:"QVv1-3-0",timestamp:new Date().toISOString(),fileHash:await D(e),originalLength:e.length,originalFilename:n||null,chunkSize:Me,chunkCount:c,domainStrings:d},f=new TextEncoder().encode(JSON.stringify(l)),w=new Uint8Array(2);new DataView(w.buffer).setUint16(0,f.length,!1);const m=new Uint8Array(4);new DataView(m.buffer).setUint32(0,s.length,!1);const p=new Uint8Array(ie.length+m.length+s.length+r.length+i.length+w.length+f.length);let S=0;p.set(ie,S),S+=ie.length,p.set(m,S),S+=m.length,p.set(s,S),S+=s.length,p.set(r,S),S+=r.length,p.set(i,S),S+=i.length,p.set(w,S),S+=w.length,p.set(f,S);const{Kraw:$,Kenc:y,Kiv:g,aesKey:x}=await zt(o,i,f,d.kdf);try{let C;if(a){const I=[];let u=0,h=0;for(;u<e.length;){const v=Math.min(Me,e.length-u),N=e.subarray(u,u+v),F=_t(g,r,h,d.iv),H=Rt(p,h,v),z=await Et(x,N,F,H);I.push(z),N.fill(0),h++,u+=v}const L=I.reduce((v,N)=>v+N.length,0),b=new Uint8Array(L);let B=0;for(const v of I)b.set(v,B),B+=v.length;C=new Blob([p,b],{type:"application/octet-stream"})}else{const I=await Et(x,e,r,p);C=new Blob([p,I],{type:"application/octet-stream"})}return C}finally{Qt(o,$,y,g)}}async function Xt(e,t){if(e.length<os)throw new Error(`File is too small to be a valid container (size: ${e.length} B).`);const n=new DataView(e.buffer,e.byteOffset);let s=0;const o=e.subarray(s,s+ie.length);if(new TextDecoder().decode(o)!==new TextDecoder().decode(ie))throw new Error("Invalid file format (magic bytes mismatch).");s+=ie.length;const r=n.getUint32(s,!1);if(s+=4,r!==1568)throw new Error(`Invalid encapsulated key length ${r}. Expected 1568 for ML-KEM-1024.`);const i=e.subarray(s,s+r);s+=r;const a=e.subarray(s,s+12);s+=12;const c=e.subarray(s,s+16);s+=16;const d=n.getUint16(s,!1);if(s+=2,d<=0||d>4096)throw new Error(`Invalid metadata length: ${d}. Must be between 1 and 4096.`);if(s+d>e.length)throw new Error("Incomplete container: metadata length exceeds file size.");const l=e.subarray(s,s+d),f=JSON.parse(new TextDecoder().decode(l));s+=d;const w=e.subarray(0,s),m=e.subarray(s),p=await ss(i,t),S=f.domainStrings||f.domain||{},{Kraw:$,Kenc:y,Kiv:g,aesKey:x}=await zt(p,c,l,S.kdf||Dt);try{let C;if(f.aead_mode==="per-chunk-aead"||f.aead_mode==="per-chunk"){const I=f.chunkCount||Vt(f.originalLength),u=[];let h=0;for(let v=0;v<I;v++){const N=Math.min(Me,f.originalLength-v*Me),F=N+16,H=m.subarray(h,h+F),z=_t(g,a,v,S.iv||"quantum-vault:chunk-iv:v1"),_=Rt(w,v,N),J=await kt(x,H,z,_);u.push(J),h+=F}const L=u.reduce((v,N)=>v+N.length,0),b=new Uint8Array(L);let B=0;for(const v of u)b.set(v,B),B+=v.length;C=new Blob([b])}else{const I=await kt(x,m,a,w);C=new Blob([I])}return{decryptedBlob:C,metadata:f}}finally{Qt(p,$,y,g)}}let _e=!1,Ue=null;function is(){const e=u=>document.getElementById(u),t=e("privKeyInput"),n=e("pubKeyInput"),s=e("dataFileInput");e("qencForQcontInput"),e("privKeyForQcontInput");const o=e("rsN"),r=e("rsK"),i=e("rsText"),a=e("rsSegData"),c=e("rsSegParity"),d=e("rsMarker");e("buildQcontBtn"),e("qcontShardsInput"),e("restoreQcontBtn");const l=e("genKeyBtn"),f=e("encBtn"),w=e("decBtn"),m=e("log");function p(u){const h=document.createElement("span");h.textContent=`[${new Date().toLocaleTimeString()}] ${u}`,m.appendChild(h),m.appendChild(document.createTextNode(`
`)),m.scrollTop=m.scrollHeight}function S(u){const h=u&&u.message?u.message:typeof u=="string"?u:String(u),L=document.createElement("span");L.className="error",L.textContent=`[${new Date().toLocaleTimeString()}] ERROR: ${h}`,m.appendChild(L),m.appendChild(document.createTextNode(`
`)),m.scrollTop=m.scrollHeight}function $(){if(!o||!r)return;let u=parseInt(o.value,10);Number.isNaN(u)&&(u=0);let h=parseInt(r.value,10);Number.isNaN(h)&&(h=0),u<0&&(u=0),h<0&&(h=0),h>=u&&(u=h+1);const L=u-h,b=L%2===0,B=b?L/2:Math.floor(L/2),v=h+B;if(i){const O=b?"":" (adjust n or k so that n − k is even)",U=u===4&&h===2?" WARNING: configuration n=4,k=2 is known to be unstable. Use n≥5 (e.g., n=5,k=3).":"";i.textContent=`Total: n=${u}. Data: k=${h}. Parity: m=${L}. Threshold: t=${v}. Need ≥ t shards to restore.${O}${U}`}const N=u?h/u*100:0,F=u?L/u*100:0,H=u?v/u*100:0;a&&(a.style.width=`${Math.max(0,Math.min(100,N))}%`),c&&(c.style.width=`${Math.max(0,Math.min(100,F))}%`),d&&(d.style.left=`${Math.max(0,Math.min(100,H))}%`);const z=document.getElementById("rsDataLabel"),_=document.getElementById("rsParityLabel"),J=document.getElementById("rsMarkerLabel");z&&(z.textContent=`k=${h} (${Math.round(h/Math.max(1,u)*100)}%)`),_&&(_.textContent=`m=${L} (${Math.round(L/Math.max(1,u)*100)}%)`),J&&(J.textContent=`t=${v}`,J.style.left=`${Math.max(0,Math.min(100,H))}%`);const ee=document.getElementById("rsTicks");if(ee&&(ee.innerHTML="",u>0))for(let O=0;O<=u;O++){const U=document.createElement("span");U.className="tick",U.style.left=`${O/u*100}%`,U.title=String(O),ee.appendChild(U)}const V=a&&a.parentElement?a.parentElement:null;V&&V.classList&&V.classList.toggle("rs-error",!b)}[o,r].forEach(u=>u&&u.addEventListener("input",$)),document.addEventListener("DOMContentLoaded",$),$();const y=e("advancedEntropyBtn"),g=e("entropyStatus"),x=e("entropyText"),C=e("entropyBar");async function I(){if(!Ue)try{g.style.display="block",x.textContent="Move mouse, type, resize window... Collecting entropy...",y.disabled=!0,y.textContent="🎲 Collecting...",Ue=new Ht;const u=setInterval(()=>{if(!Ue){clearInterval(u);return}const h=Ue.getProgress();C.style.width=`${h.percentage}%`,x.textContent=`Events: ${h.collected}/${h.required} (${h.percentage}%) | Queue: ${h.queueSize} | Est. Entropy: ${Math.round(h.estimatedEntropyBits)} bits`},200);await Ue.startCollection(),clearInterval(u),_e=!0,Ue=null,x.textContent="✅ Advanced entropy collected successfully! 64-byte seed ready.",C.style.width="100%",y.textContent="✅ Entropy Collected",y.style.backgroundColor="#28a745"}catch(u){p(`Entropy collection failed: ${u.message}`),x.textContent="❌ Entropy collection failed - will use secure random only",y.disabled=!1,y.textContent="🎲 Collect Additional Entropy"}}y?.addEventListener("click",I),l?.addEventListener("click",async()=>{W(!0);try{p("Generating ML-KEM-1024 key pair..."),p(_e?"Using crypto.getRandomValues() + collected user entropy for enhanced security":"Using crypto.getRandomValues() with 64-byte seed (secure default)");const{secretKey:u,publicKey:h,seedInfo:L}=await jt({collectUserEntropy:_e}),b=await D(u),B=await D(h);p(`Entropy source: ${L.source}${L.hasUserEntropy?" (enhanced with user entropy)":""}`),p(`Private Key: secretKey.qkey (${u.length} B) SHA3-512=${b}`),p(`Public Key: publicKey.qkey (${h.length} B) SHA3-512=${B}`),ce(new Blob([u]),"secretKey.qkey"),ce(new Blob([h]),"publicKey.qkey"),p("✅ Keys generated and downloaded successfully."),_e=!1,y&&(y.textContent="🎲 Collect Additional Entropy",y.style.backgroundColor="",y.disabled=!1),g&&(g.style.display="none")}catch(u){S(u)}finally{W(!1)}}),f?.addEventListener("click",async()=>{if(!n?.files?.[0]){S("Please select a public key (.qkey).");return}if(!s?.files?.length){S("Please select file(s) to encrypt.");return}W(!0);try{const u=await ne(n.files[0]);for(const h of s.files){p(`Encrypting file ${h.name} (${h.size} B)...`);const L=await ne(h),b=await Gt(L,u,h.name),B=await ne(b),v=await D(B);ce(b,`${h.name}.qenc`),p(`✅ File encrypted: ${h.name}.qenc (${b.size} B) SHA3-512=${v}`)}}catch(u){S(u)}finally{W(!1),s.value=""}}),w?.addEventListener("click",async()=>{if(!t?.files?.[0]){S("Please select a private key (.qkey).");return}if(!s?.files?.length){S("Please select file(s) to decrypt (.qenc).");return}W(!0);try{const u=await ne(t.files[0]);for(const h of s.files){if(!h.name.toLowerCase().endsWith(".qenc")){p(`Skipping file ${h.name} as it is not a .qenc container.`);continue}p(`Decrypting file ${h.name} (${h.size} B)...`);const L=await ne(h),b=await D(L);p(`Container hash: SHA3-512=${b}`);const{decryptedBlob:B,metadata:v}=await Xt(L,u),N=await ne(B),F=await D(N);let H=v.originalFilename;H||(H=h.name.replace(/\.qenc$/i,"")),ce(B,H),p(`✅ File decrypted: ${H} (${B.size} B)`),p(`Original file hash (from metadata): ${v.fileHash}`),p(`Hash of decrypted content: ${F}`),v.fileHash===F?p("Hashes match! File integrity verified."):S("WARNING: Hashes do NOT match! File may have been corrupted."),p(`Encrypted on (UTC): ${v.timestamp}`)}}catch(u){S(u)}finally{W(!1),s.value=""}})}const as="modulepreload",cs=function(e){return"/quantum-vault/"+e},vt={},rt=function(t,n,s){let o=Promise.resolve();if(n&&n.length>0){let c=function(d){return Promise.all(d.map(l=>Promise.resolve(l).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),a=i?.nonce||i?.getAttribute("nonce");o=c(n.map(d=>{if(d=cs(d),d in vt)return;vt[d]=!0;const l=d.endsWith(".css"),f=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${f}`))return;const w=document.createElement("link");if(w.rel=l?"stylesheet":as,l||(w.as="script"),w.crossOrigin="",w.href=d,a&&w.setAttribute("nonce",a),document.head.appendChild(w),l)return new Promise((m,p)=>{w.addEventListener("load",m),w.addEventListener("error",()=>p(new Error(`Unable to preload CSS for ${d}`)))})}))}function r(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return o.then(i=>{for(const a of i||[])a.status==="rejected"&&r(a.reason);return t().catch(r)})};function A(e,t={}){const{elementId:n="log",isLiteMode:s=!0}=t,o=document.getElementById(n);if(!o)return;const r=document.createElement("span");r.textContent=`[${qt()}] ${e}`,o.appendChild(r),o.appendChild(document.createTextNode(`
`)),o.scrollTop=o.scrollHeight}function P(e,t={}){const{elementId:n="log",isLiteMode:s=!0}=t,o=document.getElementById(n);if(!o)return;const r=e&&e.message?e.message:typeof e=="string"?e:String(e),i=document.createElement("span");i.className="error",i.textContent=`[${qt()}] ERROR: ${r}`,o.appendChild(i),o.appendChild(document.createTextNode(`
`)),o.scrollTop=o.scrollHeight}function Le(e,t,n={}){const{isLiteMode:s=!0,elementId:o="log"}=n,r=s?ot(t):t;A(`${e}: ${r}`,{elementId:o,isLiteMode:s})}function ls(e,t,n,s={}){const{isLiteMode:o=!0,elementId:r="log"}=s;o?(A("Lite Mode: ML-KEM keys generated automatically",{elementId:r,isLiteMode:o}),Le("Private Key",e,{isLiteMode:o,elementId:r}),Le("Public Key",t,{isLiteMode:o,elementId:r})):(A("Pro Mode: ML-KEM-1024 key pair generated",{elementId:r,isLiteMode:o}),A(`Entropy source: ${n.source}`,{elementId:r,isLiteMode:o}),n.hasUserEntropy&&A("✅ User entropy successfully collected and mixed",{elementId:r,isLiteMode:o}),Le("Private Key Hash",e,{isLiteMode:o,elementId:r}),Le("Public Key Hash",t,{isLiteMode:o,elementId:r}))}function ds(e,t,n,s={}){const{isLiteMode:o=!0,elementId:r="log"}=s;o?(A(`⏳ Processing: ${e} (${t} bytes)`,{elementId:r,isLiteMode:o}),Le(`✅ Encrypted: ${e} (hash)`,n,{isLiteMode:o,elementId:r})):(A(`⏳ Encrypting file: ${e}`,{elementId:r,isLiteMode:o}),A(`File size: ${t.toLocaleString()} bytes`,{elementId:r,isLiteMode:o}),Le("File hash (SHA3-512)",n,{isLiteMode:o,elementId:r}),A("✅ File encryption completed",{elementId:r,isLiteMode:o}))}function us(e,t,n,s={}){const{isLiteMode:o=!0,elementId:r="log"}=s;o?(A(`Creating shards with n=${t.n}, k=${t.k}, m=${t.m}, t=${t.t}`,{elementId:r,isLiteMode:o}),A(`Effective threshold: ${t.t} shards (${Math.round(t.t/t.n*100)}%)`,{elementId:r,isLiteMode:o}),A(`✅ Created ${e} shards for ${n}`,{elementId:r,isLiteMode:o})):(A("Reed-Solomon Configuration:",{elementId:r,isLiteMode:o}),A(`  Total shards (n): ${t.n}`,{elementId:r,isLiteMode:o}),A(`  Data shards (k): ${t.k}`,{elementId:r,isLiteMode:o}),A(`  Parity shards (m): ${t.m}`,{elementId:r,isLiteMode:o}),A(`  Shamir threshold (t): ${t.t}`,{elementId:r,isLiteMode:o}),A(`Shards created: ${e} for file "${n}"`,{elementId:r,isLiteMode:o}),A("✅ Shard creation completed successfully",{elementId:r,isLiteMode:o}))}function fs(e,t,n={}){const{isLiteMode:s=!0,elementId:o="log"}=n;s?A(`Restoring ${ot(t)} container from ${e} shard files...`,{elementId:o,isLiteMode:s}):(A("Restoration Process Started",{elementId:o,isLiteMode:s}),A(`Input shards: ${e}`,{elementId:o,isLiteMode:s}),Le("Container ID",t,{isLiteMode:s,elementId:o}))}function hs(e){if(!e.includes("."))return!/^[a-f0-9]+$/i.test(e);const t=e.split(".")[0];return/^[a-f0-9]+$/i.test(t)?!1:/[a-zA-Z]/.test(t)||/\s/.test(t)||/[-_]/.test(t)}function ys(e,t,n,s,o={}){const{isLiteMode:r=!0,elementId:i="log"}=o;if(r)if(s){const a=hs(e)?e:e.includes(".")?`${ot(e.split(".")[0])}.${e.split(".").pop()}`:e;A(`✅ Restoration complete - files have been decrypted and restored. Original file: ${a} (${t} bytes) - Encrypted on: ${n}`,{elementId:i,isLiteMode:r})}else P("⚠️ File integrity check failed - hashes do not match",{elementId:i,isLiteMode:r});else s?(A("✅ Container restoration completed successfully",{elementId:i,isLiteMode:r}),A(`Restored file: ${e}`,{elementId:i,isLiteMode:r}),A(`File size: ${t.toLocaleString()} bytes`,{elementId:i,isLiteMode:r}),A(`Original encryption time: ${n}`,{elementId:i,isLiteMode:r}),A("✅ File integrity verification passed",{elementId:i,isLiteMode:r})):(P("❌ File integrity verification failed",{elementId:i,isLiteMode:r}),A("The restored file may be corrupted or tampered with",{elementId:i,isLiteMode:r}))}function ps(e,t){return Zn(e,t)?e===4&&t===2?(alert("Warning: configuration n=4, k=2 is known to be unstable with this erasure library (edge-case decoding errors). Please choose n≥5 (recommended n=5,k=3 for balance, or n=6,k=2 for accessibility)."),!1):!0:!1}async function Jt(e,t,n){const{n:s,k:o}=n,r=s-o;if(o<2||s<=o)throw new Error("Invalid RS parameters: require 2 <= k < n");if(r%2!==0)throw new Error("n-k must be even");const i=new DataView(e.buffer,e.byteOffset);let a=0;const c=e.subarray(a,a+ie.length);if(a+=ie.length,new TextDecoder().decode(c)!==new TextDecoder().decode(ie))throw new Error("Not a .qenc");const d=i.getUint32(a,!1);a+=4;const l=e.subarray(a,a+d);a+=d;const f=e.subarray(a,a+12);a+=12;const w=e.subarray(a,a+16);a+=16;const m=i.getUint16(a,!1);a+=2;const p=e.subarray(a,a+m);a+=m;const S=e.subarray(a),$=JSON.parse(new TextDecoder().decode(p)),y=$.domainStrings||$.domain||{},g=$.originalLength||void 0,x=await D(e.subarray(0,a)),C=await D(e),I=o+r/2;if(I>s)throw new Error("Invalid threshold computed");const{splitSecret:u}=await rt(async()=>{const{splitSecret:U}=await import("./sss-DBxciO5g.js");return{splitSecret:U}},[]),h=await u(t,s,I),L=Array.from({length:s},()=>[]),b=$.chunkSize||Me,B=$.aead_mode==="per-chunk-aead"||$.aead_mode==="per-chunk",v=B?$.chunkCount||Math.ceil(g/b):1;let N=0,F=0;for(let U=0;U<v;U++){let R;if(B){const M=Math.min(b,g-U*b)+16;R=S.subarray(N,N+M),N+=M}else R=S;const ye=Math.floor(256/s)*s;if(ye===0)throw new Error("RS parameters too large");const de=ye*o/s,q=Math.ceil(R.length/de)*de;let K=R;if(q>R.length){const E=new Uint8Array(q);E.set(R),K=E}const j=window.erasure.split(K,o,r/2);if(j.length!==s)throw new Error("RS split returned unexpected number of fragments");U===0&&(F=j[0].length);for(let E=0;E<j.length;E++){const M=j[E],k=new Uint8Array(4);new DataView(k.buffer).setUint32(0,M.length,!1),L[E].push(k,M)}}const H=new Date().toISOString(),z={containerId:x,alg:{KEM:"ML-KEM-1024",KDF:"KMAC256",AEAD:"AES-256-GCM",RS:"ErasureCodes",fmt:"QVqcont-1"},aead_mode:B?"per-chunk":"single-container",iv_strategy:$.iv_strategy,n:s,k:o,m:r,t:I,chunkSize:b,chunkCount:v,containerHash:C,encapBlobHash:await D(l),privateKeyHash:await D(t),originalLength:g,ciphertextLength:S.length,domainStrings:{kdf:y.kdf||"quantum-vault:kdf:v1",iv:y.iv||"quantum-vault:iv:v1"},fragmentFormat:"len32-prefixed",perFragmentSize:F,timestamp:H},_=new TextEncoder().encode(JSON.stringify(z)),J=new Uint8Array(2);new DataView(J.buffer).setUint16(0,_.length,!1);const ee=new Uint8Array(4);new DataView(ee.buffer).setUint32(0,l.length,!1);const V=new TextEncoder().encode("QVC1"),O=[];for(let U=0;U<s;U++){const R=new Blob(L[U]),ye=new Uint8Array(await R.arrayBuffer()),de=new Uint8Array(2);new DataView(de.buffer).setUint16(0,p.length,!1);const q=new Uint8Array(V.length+2+_.length+4+l.length+12+16+2+p.length+2+2+h[U].length);let K=0;q.set(V,K),K+=V.length,q.set(J,K),K+=2,q.set(_,K),K+=_.length,q.set(ee,K),K+=4,q.set(l,K),K+=l.length,q.set(f,K),K+=12,q.set(w,K),K+=16,q.set(de,K),K+=2,q.set(p,K),K+=p.length;const j=new Uint8Array(2);new DataView(j.buffer).setUint16(0,U,!1),q.set(j,K),K+=2;const E=new Uint8Array(2);new DataView(E.buffer).setUint16(0,h[U].length,!1),q.set(E,K),K+=2,q.set(h[U],K);const M=new Blob([q,ye],{type:"application/octet-stream"});O.push({blob:M,index:U})}return O}function ms(){const e=document.getElementById("qencForQcontInput"),t=document.getElementById("privKeyForQcontInput"),n=document.getElementById("rsN"),s=document.getElementById("rsK");document.getElementById("buildQcontBtn")?.addEventListener("click",async()=>{if(!e?.files?.[0]){P("Select .qenc");return}if(!t?.files?.[0]){P("Select private .qkey to split");return}const r=t.files[0];if(r.size!==3168){P(`Private .qkey must be exactly 3168 bytes (got ${r.size} B)`);return}W(!0);try{const i=await ne(e.files[0]),a=await ne(t.files[0]),c=parseInt(n.value,10),d=parseInt(s.value,10);if(Number.isNaN(c)||Number.isNaN(d))throw new Error("Invalid parameters");if(d<2||c<=d)throw new Error("Require 2 <= k < n");if((c-d)%2!==0)throw new Error("(n - k) must be even");if(!ps(c,d))return;const l=d+(c-d)/2;A(`Building .qcont shards with n=${c}, k=${d}, m=${c-d} (t=${l}), chunkSize=8 MiB ...`);const f=await Jt(i,a,{n:c,k:d}),w=e.files[0].name.replace(/\.qenc$/i,"");f.forEach(({blob:m,index:p})=>{const S=`${w}.part${p+1}-of-${f.length}.qcont`;ce(m,S),A(`Saved ${S} (${m.size} B)`)}),A(".qcont shards built. Distribute files across storage providers.")}catch(i){P(i)}finally{W(!1)}})}function gs(){const e=document.getElementById("qcontShardsInput");document.getElementById("restoreQcontBtn")?.addEventListener("click",async()=>{const n=e?.files;if(!n?.length){P("Select .qcont shards");return}if(n.length<2){P("Select at least two .qcont shards");return}const s=n[0].size;for(let o=1;o<n.length;o++)if(n[o].size!==s){P("All selected .qcont shards must have the same file size.");return}W(!0);try{const r=(await Promise.all([...n].map(ne))).map(E=>{const M=new DataView(E.buffer,E.byteOffset);let k=0;const te=new TextDecoder().decode(E.subarray(k,k+4));if(k+=4,te!=="QVC1")throw new Error("Invalid .qcont magic");const se=M.getUint16(k,!1);k+=2;const ge=JSON.parse(new TextDecoder().decode(E.subarray(k,k+se)));k+=se;const Y=M.getUint32(k,!1);k+=4;const T=E.subarray(k,k+Y);k+=Y;const oe=E.subarray(k,k+12);k+=12;const pe=E.subarray(k,k+16);k+=16;const Q=M.getUint16(k,!1);k+=2;const re=E.subarray(k,k+Q);k+=Q;const Be=M.getUint16(k,!1);k+=2;const Ee=M.getUint16(k,!1);k+=2;const we=E.subarray(k,k+Ee);k+=Ee;const me=E.subarray(k);return{metaJSON:ge,encapsulatedKey:T,iv:oe,salt:pe,qencMetaBytes:re,shardIndex:Be,share:we,fragments:me}});if(new Set(r.map(E=>E.metaJSON?.containerId)).size!==1){P("Selected shards belong to different containers (containerId mismatch).");return}const a=new Map;for(const E of r){const M=E.metaJSON.containerId;a.has(M)||a.set(M,[]),a.get(M).push(E)}const[c,d]=[...a.entries()][0],{n:l,k:f,m:w,t:m,ciphertextLength:p,chunkSize:S,chunkCount:$,containerHash:y,privateKeyHash:g,aead_mode:x,perFragmentSize:C}=d[0].metaJSON,I=x==="per-chunk"||x==="per-chunk-aead";for(const E of d){const M=E.metaJSON;if(M.containerId!==c||M.n!==l||M.k!==f||M.m!==w||M.t!==m)throw new Error("Shard parameter mismatch (containerId/n/k/m/t)")}if(await D(d[0].encapsulatedKey)!==d[0].metaJSON.encapBlobHash)throw new Error("encapBlobHash mismatch");if(d.length<m)throw new Error(`Need at least ${m} shards, got ${d.length}`);const L=d.slice().sort((E,M)=>E.shardIndex-M.shardIndex).slice(0,m).map(E=>E.share),{combineShares:b}=await rt(async()=>{const{combineShares:E}=await import("./sss-DBxciO5g.js");return{combineShares:E}},[]),B=await b(L),N=Math.floor(256/l)*l*f/l,F=p,H=$,z=[],_=new Array(l).fill(0);for(let E=0;E<H;E++){const M=Math.min(S,d[0].metaJSON.originalLength-E*S),k=I?M+16:F,se=Math.floor(256/l)*l*f/l,ge=se/f,T=Math.ceil(k/se)*ge,oe=new Array(l);for(let Q=0;Q<l;Q++){const re=d.find(ke=>ke.shardIndex===Q)?.fragments;if(!re){oe[Q]=new Uint8Array(T);continue}const Be=re.length,Ee=_[Q];if(Ee+4>Be)throw new Error("Fragment stream underflow");const me=new DataView(re.buffer,re.byteOffset+Ee).getUint32(0,!1),qe=Ee+4,ae=qe+me;if(ae>Be)throw new Error("Fragment length overflow");let ue=re.subarray(qe,ae);if(me<T){const ke=new Uint8Array(T);ke.set(ue),ue=ke}else me>T&&(ue=ue.subarray(0,T));oe[Q]=ue,_[Q]=ae}const pe=window.erasure.recombine(oe,k,f,w/2);if(z.push(pe),!I)break}const J=I?(()=>{const E=z.reduce((te,se)=>te+se.length,0),M=new Uint8Array(E);let k=0;for(const te of z)M.set(te,k),k+=te.length;return M})():z[0],ee=(()=>{const{encapsulatedKey:E,iv:M,salt:k,qencMetaBytes:te}=d[0],se=new Uint8Array(4);new DataView(se.buffer).setUint32(0,E.length,!1);const ge=new Uint8Array(2);new DataView(ge.buffer).setUint16(0,te.length,!1);const Y=new Uint8Array(ie.length+4+E.length+12+16+2+te.length);let T=0;return Y.set(ie,T),T+=ie.length,Y.set(se,T),T+=4,Y.set(E,T),T+=E.length,Y.set(M,T),T+=12,Y.set(k,T),T+=16,Y.set(ge,T),T+=2,Y.set(te,T),Y})(),V=new Uint8Array(ee.length+J.length);V.set(ee,0),V.set(J,ee.length);const O=await D(V),U=await D(B),R=O===y,ye=U===g;A(`Recovered .qenc SHA3-512=${O} (expected ${y})`),A(R?"Hashes match! File integrity verified.":"WARNING: .qenc hash mismatch!"),A(`Recovered .qkey SHA3-512=${U} (expected ${g})`),A(ye?"Hashes match! File integrity verified.":"WARNING: .qkey hash mismatch!");const de=new Blob([V],{type:"application/octet-stream"}),q=new Blob([B],{type:"application/octet-stream"}),K=`${c}.recovered.qenc`,j=`${c}.recovered.secretKey.qkey`;if(R&&ye)ce(de,K),ce(q,j),A("✅ Recovered .qenc and .qkey from .qcont shards.");else{P("Hash mismatch detected. Automatic download is blocked. Review and download manually if needed.");const E=document.createElement("a");E.href=URL.createObjectURL(de),E.download=K,E.textContent=`Manual download: ${K}`,E.target="_blank",E.rel="noopener";const M=document.createElement("a");M.href=URL.createObjectURL(q),M.download=j,M.textContent=`Manual download: ${j}`,M.target="_blank",M.rel="noopener";const k=document.getElementById("log");k.appendChild(E),k.appendChild(document.createTextNode(`
`)),k.appendChild(M),k.appendChild(document.createTextNode(`
`))}}catch(o){P(o)}finally{W(!1)}})}let le=null,Ze=!0,et=new Map;function it(e,t){if(e<5)return{error:"Total shards must be at least 5 (configurations with n≤4 are unstable)"};let s=2*Math.ceil(t/100*e)-e;s=Math.max(3,Math.min(s,e-1));let o=e-s;if(o%2!==0){if(s+1<e&&s+1>=3)s+=1;else if(s-1>=3)s-=1;else return{error:"Cannot find valid configuration - try adjusting total shards or threshold"};o=e-s}if(e<=4&&s<=2)return{error:"Configuration n≤4, k≤2 is unstable. Please use n≥5 with k≥3"};const r=es(e,s),i=Math.round(r/e*100);return r!==Math.floor(r)?{error:"Invalid configuration results in fractional threshold"}:{n:e,k:s,m:o,t:Math.floor(r),actualThresholdPercent:i}}function We(){const e=document.getElementById("liteN"),t=document.getElementById("liteThreshold"),n=document.getElementById("thresholdText"),s=document.getElementById("configValidation");if(!e||!t||!n)return;const o=parseInt(e.value,10),r=parseInt(t.value,10);if(s&&(s.style.display="none",s.className="validation-message"),isNaN(o)||isNaN(r)||o<5){n.textContent="Invalid parameters",s&&o<5&&o>0&&(s.textContent="Total shards must be at least 5 (configurations with n≤4 are unstable)",s.style.display="block"),Fe();return}const i=it(o,r);if(i.error){n.textContent="Configuration Error",s&&(s.textContent=i.error,s.style.display="block"),Fe();return}n.textContent=`≥${i.t} shards required for recovery (${i.actualThresholdPercent}%)`,s&&i.actualThresholdPercent!==r?(s.className="validation-message warning",s.textContent=`Configuration adjusted: actual threshold is ${i.actualThresholdPercent}% (${i.t} shards)`,s.style.display="block"):s&&(s.className="validation-message success",s.textContent=`✓ Valid configuration: n=${i.n}, k=${i.k}, t=${i.t}`,s.style.display="block"),Fe()}async function ws(){try{const e=document.getElementById("keyStatus"),t=e?.querySelector(".status-text"),n=e?.querySelector(".status-icon");t&&(t.textContent="Generating keys..."),n&&(n.textContent="🔄");const s=await jt({collectUserEntropy:!1});le=s;const o=await D(le.secretKey),r=await D(le.publicKey);ls(o,r,s.seedInfo,{isLiteMode:!0}),t&&(t.textContent="Keys ready ✓"),n&&(n.textContent="🔑");const i=document.getElementById("liteFilesInput");i&&(i.disabled=!1);const a=document.getElementById("liteDownloadKeysBtn");a&&(a.style.display="inline-block"),Fe()}catch(e){P(`Failed to generate keys: ${e.message}`,{isLiteMode:!0});const t=document.getElementById("keyStatus")?.querySelector(".status-text"),n=document.getElementById("keyStatus")?.querySelector(".status-icon");t&&(t.textContent="Key generation failed ✗"),n&&(n.textContent="❌")}}function Fe(){const e=document.getElementById("liteCreateShardsBtn"),t=document.getElementById("liteFilesInput"),n=document.getElementById("liteN"),s=document.getElementById("liteThreshold");if(!e||!t)return;const o=le!==null,r=t.files&&t.files.length>0;let i=!1;if(n&&s){const a=parseInt(n.value,10),c=parseInt(s.value,10);!isNaN(a)&&!isNaN(c)&&a>=5&&(i=!it(a,c).error)}e.disabled=!o||!r||!i}function bs(){if(!le){P("No keys available to download",{isLiteMode:!0});return}const e=Wn();ce(new Blob([le.secretKey]),`quantum-vault-${e}-secretKey.qkey`),ce(new Blob([le.publicKey]),`quantum-vault-${e}-publicKey.qkey`),A("✅ Backup keys downloaded",{isLiteMode:!0})}async function Es(){const e=document.getElementById("liteFilesInput"),t=document.getElementById("liteN"),n=document.getElementById("liteThreshold");if(!e?.files?.length){P("Please select files to encrypt",{isLiteMode:!0});return}if(!le){P("Keys not ready",{isLiteMode:!0});return}const s=parseInt(t.value,10),o=parseInt(n.value,10);if(isNaN(s)||isNaN(o)){P("Invalid parameters",{isLiteMode:!0});return}W(!0);try{const r=it(s,o);for(const i of e.files){const a=await ne(i),c=await Gt(a,le.publicKey,i.name),d=await ne(c),l=await D(d);et.set(l,i.name),ds(i.name,i.size,l,{isLiteMode:!0});const f=await Jt(d,le.secretKey,{n:r.n,k:r.k}),w=i.name.replace(/\.[^/.]+$/,"");f.forEach(({blob:m,index:p})=>{const S=`${w}.part${p+1}-of-${f.length}.qcont`;ce(m,S)}),us(f.length,r,i.name,{isLiteMode:!0})}A("🛡️ All files encrypted and split into shards",{isLiteMode:!0}),A("Distribute shards across different storage locations for security",{isLiteMode:!0})}catch(r){P(`Failed to create shards: ${r.message}`,{isLiteMode:!0})}finally{W(!1)}}async function ks(){const e=document.getElementById("liteShardsInput");if(!e?.files?.length){P("Please select shard files to restore",{isLiteMode:!0});return}if(e.files.length<2){P("Please select at least 2 shard files",{isLiteMode:!0});return}W(!0);try{const n=(await Promise.all([...e.files].map(ne))).map(i=>{const a=new DataView(i.buffer,i.byteOffset);let c=0;const d=new TextDecoder().decode(i.subarray(c,c+4));if(c+=4,d!=="QVC1")throw new Error("Invalid .qcont magic");const l=a.getUint16(c,!1);c+=2;const f=JSON.parse(new TextDecoder().decode(i.subarray(c,c+l)));c+=l;const w=a.getUint32(c,!1);c+=4;const m=i.subarray(c,c+w);c+=w;const p=i.subarray(c,c+12);c+=12;const S=i.subarray(c,c+16);c+=16;const $=a.getUint16(c,!1);c+=2;const y=i.subarray(c,c+$);c+=$;const g=a.getUint16(c,!1);c+=2;const x=a.getUint16(c,!1);c+=2;const C=i.subarray(c,c+x);c+=x;const I=i.subarray(c);return{metaJSON:f,encapsulatedKey:m,iv:p,salt:S,qencMetaBytes:y,shardIndex:g,share:C,fragments:I}});if(new Set(n.map(i=>i.metaJSON?.containerId)).size!==1){P("Selected shards belong to different containers (containerId mismatch)",{isLiteMode:!0});return}const o=new Map;for(const i of n){const a=i.metaJSON.containerId;o.has(a)||o.set(a,[]),o.get(a).push(i)}for(const[i,a]of o.entries()){fs(e.files.length,i,{isLiteMode:!0});const{n:c,k:d,m:l,t:f,ciphertextLength:w,chunkSize:m,chunkCount:p,containerHash:S,privateKeyHash:$,aead_mode:y}=a[0].metaJSON,g=y==="per-chunk"||y==="per-chunk-aead";if(a.length<f)throw new Error(`Need at least ${f} shards for container, got ${a.length}`);const C=a.slice().sort((T,oe)=>T.shardIndex-oe.shardIndex).slice(0,f).map(T=>T.share),{combineShares:I}=await rt(async()=>{const{combineShares:T}=await import("./sss-DBxciO5g.js");return{combineShares:T}},[]),u=await I(C),L=Math.floor(256/c)*c*d/c,b=p,B=[],v=new Array(c).fill(0);for(let T=0;T<b;T++){const oe=Math.min(m,a[0].metaJSON.originalLength-T*m),pe=g?oe+16:w,re=Math.floor(256/c)*c*d/c,Be=re/d,we=Math.ceil(pe/re)*Be,me=new Array(c);for(let ae=0;ae<c;ae++){const ue=a.find(De=>De.shardIndex===ae)?.fragments;if(!ue){me[ae]=new Uint8Array(we);continue}const ke=v[ae],Xe=new DataView(ue.buffer,ue.byteOffset+ke).getUint32(0,!1),at=ke+4,ct=at+Xe;let Ce=ue.subarray(at,ct);if(Xe<we){const De=new Uint8Array(we);De.set(Ce),Ce=De}else Xe>we&&(Ce=Ce.subarray(0,we));me[ae]=Ce,v[ae]=ct}const qe=window.erasure.recombine(me,pe,d,l/2);if(B.push(qe),!g)break}const N=g?(()=>{const T=B.reduce((Q,re)=>Q+re.length,0),oe=new Uint8Array(T);let pe=0;for(const Q of B)oe.set(Q,pe),pe+=Q.length;return oe})():B[0],{encapsulatedKey:F,iv:H,salt:z,qencMetaBytes:_}=a[0],J=new Uint8Array(4);new DataView(J.buffer).setUint32(0,F.length,!1);const ee=new Uint8Array(2);new DataView(ee.buffer).setUint16(0,_.length,!1);const V=new TextEncoder().encode("QVv1"),O=new Uint8Array(V.length+4+F.length+12+16+2+_.length);let U=0;O.set(V,U),U+=V.length,O.set(J,U),U+=4,O.set(F,U),U+=F.length,O.set(H,U),U+=12,O.set(z,U),U+=16,O.set(ee,U),U+=2,O.set(_,U);const R=new Uint8Array(O.length+N.length);R.set(O,0),R.set(N,O.length);const ye=await D(R),de=await D(u);if(!(ye===S)||!(de===$)){P("Hash verification failed for container",{isLiteMode:!0});continue}const{decryptedBlob:j,metadata:E}=await Xt(R,u),M=await D(R);let k=et.get(M);k||(k=et.get(S)),k||(k=`restored-${i.slice(0,8)}.file`),ce(j,k);const te=await ne(j),se=await D(te),ge=E.fileHash===se,Y=E.timestamp||"Unknown";ys(k,j.size,Y,ge,{isLiteMode:!0})}const r=o.size;r===1?A("🎉 Container restored successfully",{isLiteMode:!0}):A(`🎉 ${r} containers restored successfully`,{isLiteMode:!0})}catch(t){P(`Restoration failed: ${t.message}`,{isLiteMode:!0})}finally{W(!1)}}function St(){const e=document.getElementById("modeToggle"),t=document.getElementById("liteMode"),n=document.getElementById("proMode");!e||!t||!n||(Ze=!e.checked,Ze?(t.style.display="block",n.style.display="none",A("Switched to Lite Mode",{isLiteMode:!0}),le||ws()):(t.style.display="none",n.style.display="block",A("Switched to Pro Mode",{isLiteMode:!1})))}function vs(){const e=document.getElementById("modeToggle");e&&e.addEventListener("change",St);const t=document.getElementById("liteN"),n=document.getElementById("liteThreshold");t&&n&&(t.addEventListener("input",We),n.addEventListener("input",We),We());const s=document.getElementById("liteFilesInput");s&&(s.addEventListener("change",Fe),s.disabled=!0);const o=document.getElementById("liteDownloadKeysBtn");o&&o.addEventListener("click",bs);const r=document.getElementById("liteCreateShardsBtn");r&&r.addEventListener("click",Es);const i=document.getElementById("liteRestoreBtn");i&&i.addEventListener("click",ks),Ze=!0,e&&(e.checked=!1),St(),A("Lite Mode initialized - toggle to switch to Pro mode",{isLiteMode:!0})}function It(){is(),ms(),gs(),vs(),console.log("Quantum Vault application initialized successfully")}typeof window<"u"&&(document.readyState==="loading"?document.addEventListener("DOMContentLoaded",It):It());export{rt as _};

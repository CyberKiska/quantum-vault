(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();const je=BigInt(2**32-1),xt=BigInt(32);function Cn(e,t=!1){return t?{h:Number(e&je),l:Number(e>>xt&je)}:{h:Number(e>>xt&je)|0,l:Number(e&je)|0}}function Un(e,t=!1){const n=e.length;let s=new Uint32Array(n),r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:i,l:a}=Cn(e[o],t);[s[o],r[o]]=[i,a]}return[s,r]}const Nn=(e,t,n)=>e<<n|t>>>32-n,Tn=(e,t,n)=>t<<n|e>>>32-n,Kn=(e,t,n)=>t<<n-32|e>>>64-n,Fn=(e,t,n)=>e<<n-32|t>>>64-n;function On(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function $t(e,t=""){if(!Number.isSafeInteger(e)||e<0){const n=t&&`"${t}" `;throw new Error(`${n}expected integer >= 0, got ${e}`)}}function te(e,t,n=""){const s=On(e),r=e?.length,o=t!==void 0;if(!s||o&&r!==t){const i=n&&`"${n}" `,a=o?` of length ${t}`:"",c=s?`length=${r}`:`type=${typeof e}`;throw new Error(i+"expected Uint8Array"+a+", got "+c)}return e}function At(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Pn(e,t){te(e,void 0,"digestInto() output");const n=t.outputLen;if(e.length<n)throw new Error('"digestInto() output" expected to be of length >='+n)}function yt(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function Vt(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}const qn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Rn(e){return e<<24&4278190080|e<<8&16711680|e>>>8&65280|e>>>24&255}function Hn(e){for(let t=0;t<e.length;t++)e[t]=Rn(e[t]);return e}const Mt=qn?e=>e:Hn;function Dn(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function zn(e,t=""){return typeof e=="string"?Dn(e):te(e,void 0,t)}function Qt(e,t={}){const n=(r,o)=>e(o).update(r).digest(),s=e(void 0);return n.outputLen=s.outputLen,n.blockLen=s.blockLen,n.create=r=>e(r),Object.assign(n,t),Object.freeze(n)}function _n(e=32){const t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}const tt=e=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,e])}),Vn=BigInt(0),Fe=BigInt(1),Qn=BigInt(2),jn=BigInt(7),Jn=BigInt(256),Gn=BigInt(113),jt=[],Jt=[],Gt=[];for(let e=0,t=Fe,n=1,s=0;e<24;e++){[n,s]=[s,(2*n+3*s)%5],jt.push(2*(5*s+n)),Jt.push((e+1)*(e+2)/2%64);let r=Vn;for(let o=0;o<7;o++)t=(t<<Fe^(t>>jn)*Gn)%Jn,t&Qn&&(r^=Fe<<(Fe<<BigInt(o))-Fe);Gt.push(r)}const Xt=Un(Gt,!0),Xn=Xt[0],Yn=Xt[1],Ct=(e,t,n)=>n>32?Kn(e,t,n):Nn(e,t,n),Ut=(e,t,n)=>n>32?Fn(e,t,n):Tn(e,t,n);function Wn(e,t=24){const n=new Uint32Array(10);for(let s=24-t;s<24;s++){for(let i=0;i<10;i++)n[i]=e[i]^e[i+10]^e[i+20]^e[i+30]^e[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,d=n[c],l=n[c+1],u=Ct(d,l,1)^n[a],h=Ut(d,l,1)^n[a+1];for(let y=0;y<50;y+=10)e[i+y]^=u,e[i+y+1]^=h}let r=e[2],o=e[3];for(let i=0;i<24;i++){const a=Jt[i],c=Ct(r,o,a),d=Ut(r,o,a),l=jt[i];r=e[l],o=e[l+1],e[l]=c,e[l+1]=d}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)n[a]=e[i+a];for(let a=0;a<10;a++)e[i+a]^=~n[(a+2)%10]&n[(a+4)%10]}e[0]^=Xn[s],e[1]^=Yn[s]}Vt(n)}class Qe{state;pos=0;posOut=0;finished=!1;state32;destroyed=!1;blockLen;suffix;outputLen;enableXOF=!1;rounds;constructor(t,n,s,r=!1,o=24){if(this.blockLen=t,this.suffix=n,this.outputLen=s,this.enableXOF=r,this.rounds=o,$t(s,"outputLen"),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=yt(this.state)}clone(){return this._cloneInto()}keccak(){Mt(this.state32),Wn(this.state32,this.rounds),Mt(this.state32),this.posOut=0,this.pos=0}update(t){At(this),te(t);const{blockLen:n,state:s}=this,r=t.length;for(let o=0;o<r;){const i=Math.min(n-this.pos,r-o);for(let a=0;a<i;a++)s[this.pos++]^=t[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:n,pos:s,blockLen:r}=this;t[s]^=n,(n&128)!==0&&s===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){At(this,!1),te(t),this.finish();const n=this.state,{blockLen:s}=this;for(let r=0,o=t.length;r<o;){this.posOut>=s&&this.keccak();const i=Math.min(s-this.posOut,o-r);t.set(n.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return $t(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(Pn(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Vt(this.state)}_cloneInto(t){const{blockLen:n,suffix:s,outputLen:r,rounds:o,enableXOF:i}=this;return t||=new Qe(n,s,r,i,o),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=o,t.suffix=s,t.outputLen=r,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Yt=(e,t,n,s={})=>Qt(()=>new Qe(t,e,n),s),Wt=Yt(6,136,32,tt(8)),Ee=Yt(6,72,64,tt(10)),Zt=(e,t,n,s={})=>Qt((r={})=>new Qe(t,e,r.dkLen===void 0?n:r.dkLen,!0),s),Zn=Zt(31,168,16,tt(11)),en=Zt(31,136,32,tt(12));function pt(e){if(!Number.isSafeInteger(e)||e<0||e>4294967295)throw new Error("wrong u32 integer:"+e);return e}function tn(e){return pt(e),(e&e-1)===0&&e!==0}function nn(e,t){pt(e);let n=0;for(let s=0;s<t;s++,e>>>=1)n=n<<1|e&1;return n}function rn(e){return pt(e),31-Math.clz32(e)}function Nt(e){const t=e.length;if(t<2||!tn(t))throw new Error("n must be a power of 2 and greater than 1. Got "+t);const n=rn(t);for(let s=0;s<t;s++){const r=nn(s,n);if(s<r){const o=e[s];e[s]=e[r],e[r]=o}}return e}const Tt=(e,t)=>{const{N:n,roots:s,dit:r,invertButterflies:o=!1,skipStages:i=0,brp:a=!0}=t,c=rn(n);if(!tn(n))throw new Error("FFT: Polynomial size should be power of two");const d=r!==o;return l=>{if(l.length!==n)throw new Error("FFT: wrong Polynomial length");r&&a&&Nt(l);for(let u=0,h=1;u<c-i;u++){const y=r?u+1+i:c-u,L=1<<y,U=L>>1,x=n>>y;for(let f=0;f<n;f+=L)for(let m=0,w=h++;m<U;m++){const $=o?r?n-w:w:m*x,k=f+m,v=f+m+U,B=s[$],b=l[v],I=l[k];if(d){const N=e.mul(b,B);l[k]=e.add(I,N),l[v]=e.sub(I,N)}else o?(l[k]=e.add(b,I),l[v]=e.mul(e.sub(b,I),B)):(l[k]=e.add(I,b),l[v]=e.mul(e.sub(I,b),B))}}return!r&&a&&Nt(l),l}};const Kt=_n;function at(e,t){if(e.length!==t.length)return!1;let n=0;for(let s=0;s<e.length;s++)n|=e[s]^t[s];return n===0}function er(e){return Uint8Array.from(e)}function Xe(e,...t){const n=r=>typeof r=="number"?r:r.bytesLen,s=t.reduce((r,o)=>r+n(o),0);return{bytesLen:s,encode:r=>{const o=new Uint8Array(s);for(let i=0,a=0;i<t.length;i++){const c=t[i],d=n(c),l=typeof c=="number"?r[i]:c.encode(r[i]);te(l,d,e),o.set(l,a),typeof c!="number"&&l.fill(0),a+=d}return o},decode:r=>{te(r,s,e);const o=[];for(const i of t){const a=n(i),c=r.subarray(0,a);o.push(typeof i=="number"?c:i.decode(c)),r=r.subarray(a)}return o}}}function ct(e,t){const n=t*e.bytesLen;return{bytesLen:n,encode:s=>{if(s.length!==t)throw new Error(`vecCoder.encode: wrong length=${s.length}. Expected: ${t}`);const r=new Uint8Array(n);for(let o=0,i=0;o<s.length;o++){const a=e.encode(s[o]);r.set(a,i),a.fill(0),i+=a.length}return r},decode:s=>{te(s,n);const r=[];for(let o=0;o<s.length;o+=e.bytesLen)r.push(e.decode(s.subarray(o,o+e.bytesLen)));return r}}}function ge(...e){for(const t of e)if(Array.isArray(t))for(const n of t)n.fill(0);else t.fill(0)}function Ft(e){return(1<<e)-1}const tr=e=>{const{newPoly:t,N:n,Q:s,F:r,ROOT_OF_UNITY:o,brvBits:i}=e,a=(f,m=s)=>{const w=f%m|0;return(w>=0?w|0:m+w|0)|0},c=(f,m=s)=>{const w=a(f,m)|0;return(w>m>>1?w-m|0:w)|0};function d(){const f=t(n);for(let m=0;m<n;m++){const w=nn(m,i),$=BigInt(o)**BigInt(w)%BigInt(s);f[m]=Number($)|0}return f}const l=d(),u={add:(f,m)=>a((f|0)+(m|0))|0,sub:(f,m)=>a((f|0)-(m|0))|0,mul:(f,m)=>a((f|0)*(m|0))|0,inv:f=>{throw new Error("not implemented")}},h={N:n,roots:l,invertButterflies:!0,skipStages:1,brp:!1},y=Tt(u,{dit:!1,...h}),L=Tt(u,{dit:!0,...h});return{mod:a,smod:c,nttZetas:l,NTT:{encode:f=>y(f),decode:f=>{L(f);for(let m=0;m<f.length;m++)f[m]=a(r*f[m]);return f}},bitsCoder:(f,m)=>{const w=Ft(f),$=f*(n/8);return{bytesLen:$,encode:k=>{const v=new Uint8Array($);for(let B=0,b=0,I=0,N=0;B<k.length;B++)for(b|=(m.encode(k[B])&w)<<I,I+=f;I>=8;I-=8,b>>=8)v[N++]=b&Ft(I);return v},decode:k=>{const v=t(n);for(let B=0,b=0,I=0,N=0;B<k.length;B++)for(b|=k[B]<<I,I+=8;I>=f;I-=f,b>>=f)v[N++]=m.decode(b&w);return v}}}}},nr=e=>(t,n)=>{n||(n=e.blockLen);const s=new Uint8Array(t.length+2);s.set(t);const r=t.length,o=new Uint8Array(n);let i=e.create({}),a=0,c=0;return{stats:()=>({calls:a,xofs:c}),get:(d,l)=>(s[r+0]=d,s[r+1]=l,i.destroy(),i=e.create({}).update(s),a++,()=>(c++,i.xofInto(o))),clean:()=>{i.destroy(),ge(o,s)}}},rr=nr(Zn);const ie=256,Le=3329,sr=3303,or=17,{mod:ze,nttZetas:ir,NTT:Ie,bitsCoder:ar}=tr({N:ie,Q:Le,F:sr,ROOT_OF_UNITY:or,newPoly:e=>new Uint16Array(e),brvBits:7}),cr={1024:{N:ie,Q:Le,K:4,ETA1:2,ETA2:2,du:11,dv:5,RBGstrength:256}},lr=e=>{if(e>=12)return{encode:n=>n,decode:n=>n};const t=2**(e-1);return{encode:n=>((n<<e)+Le/2)/Le,decode:n=>n*Le+t>>>e}},Oe=e=>ar(e,lr(e));function ke(e,t){for(let n=0;n<ie;n++)e[n]=ze(e[n]+t[n])}function dr(e,t){for(let n=0;n<ie;n++)e[n]=ze(e[n]-t[n])}function ur(e,t,n,s,r){const o=ze(t*s*r+e*n),i=ze(e*s+t*n);return{c0:o,c1:i}}function Je(e,t){for(let n=0;n<ie/2;n++){let s=ir[64+(n>>1)];n&1&&(s=-s);const{c0:r,c1:o}=ur(e[2*n+0],e[2*n+1],t[2*n+0],t[2*n+1],s);e[2*n+0]=r,e[2*n+1]=o}return e}function Ot(e){const t=new Uint16Array(ie);for(let n=0;n<ie;){const s=e();if(s.length%3)throw new Error("SampleNTT: unaligned block");for(let r=0;n<ie&&r+3<=s.length;r+=3){const o=(s[r+0]>>0|s[r+1]<<8)&4095,i=(s[r+1]>>4|s[r+2]<<4)&4095;o<Le&&(t[n++]=o),n<ie&&i<Le&&(t[n++]=i)}}return t}function Pe(e,t,n,s){const r=e(s*ie/4,t,n),o=new Uint16Array(ie),i=yt(r);let a=0;for(let c=0,d=0,l=0,u=0;c<i.length;c++){let h=i[c];for(let y=0;y<32;y++)l+=h&1,h>>=1,a+=1,a===s?(u=l,l=0):a===2*s&&(o[d++]=ze(u-l),l=0,a=0)}if(a)throw new Error(`sampleCBD: leftover bits: ${a}`);return o}const hr=e=>{const{K:t,PRF:n,XOF:s,HASH512:r,ETA1:o,ETA2:i,du:a,dv:c}=e,d=Oe(1),l=Oe(c),u=Oe(a),h=Xe("publicKey",ct(Oe(12),t),32),y=ct(Oe(12),t),L=Xe("ciphertext",ct(u,t),l),U=Xe("seed",32,32);return{secretCoder:y,lengths:{secretKey:y.bytesLen,publicKey:h.bytesLen,cipherText:L.bytesLen},keygen:x=>{te(x,32,"seed");const f=new Uint8Array(33);f.set(x),f[32]=t;const m=r(f),[w,$]=U.decode(m),k=[],v=[];for(let I=0;I<t;I++)k.push(Ie.encode(Pe(n,$,I,o)));const B=s(w);for(let I=0;I<t;I++){const N=Ie.encode(Pe(n,$,t+I,o));for(let M=0;M<t;M++){const F=Ot(B.get(M,I));ke(N,Je(F,k[M]))}v.push(N)}B.clean();const b={publicKey:h.encode([v,w]),secretKey:y.encode(k)};return ge(w,$,k,v,f,m),b},encrypt:(x,f,m)=>{const[w,$]=h.decode(x),k=[];for(let M=0;M<t;M++)k.push(Ie.encode(Pe(n,m,M,o)));const v=s($),B=new Uint16Array(ie),b=[];for(let M=0;M<t;M++){const F=Pe(n,m,t+M,i),H=new Uint16Array(ie);for(let V=0;V<t;V++){const ae=Ot(v.get(M,V));ke(H,Je(ae,k[V]))}ke(F,Ie.decode(H)),b.push(F),ke(B,Je(w[M],k[M])),ge(H)}v.clean();const I=Pe(n,m,2*t,i);ke(I,Ie.decode(B));const N=d.decode(f);return ke(N,I),ge(w,k,B,I),L.encode([b,N])},decrypt:(x,f)=>{const[m,w]=L.decode(x),$=y.decode(f),k=new Uint16Array(ie);for(let v=0;v<t;v++)ke(k,Je($[v],Ie.encode(m[v])));return dr(w,Ie.decode(k)),ge(k,$,m),d.encode(w)}}};function fr(e){const t=hr(e),{HASH256:n,HASH512:s,KDF:r}=e,{secretCoder:o,lengths:i}=t,a=Xe("secretKey",i.secretKey,i.publicKey,32,32),c=32,d=64;return{info:{type:"ml-kem"},lengths:{...i,seed:64,msg:c,msgRand:c,secretKey:a.bytesLen},keygen:(l=Kt(d))=>{te(l,d,"seed");const{publicKey:u,secretKey:h}=t.keygen(l.subarray(0,32)),y=n(u),L=a.encode([h,u,y,l.subarray(32)]);return ge(h,y),{publicKey:u,secretKey:L}},getPublicKey:l=>{const[u,h]=a.decode(l);return Uint8Array.from(h)},encapsulate:(l,u=Kt(c))=>{te(l,i.publicKey,"publicKey"),te(u,c,"message");const h=l.subarray(0,384*e.K),y=o.encode(o.decode(er(h)));if(!at(y,h))throw ge(y),new Error("ML-KEM.encapsulate: wrong publicKey modulus");ge(y);const L=s.create().update(u).update(n(l)).digest(),U=t.encrypt(l,u,L.subarray(32,64));return ge(L.subarray(32)),{cipherText:U,sharedSecret:L.subarray(0,32)}},decapsulate:(l,u)=>{te(u,a.bytesLen,"secretKey"),te(l,i.cipherText,"cipherText");const h=a.bytesLen-96,y=h+32,L=n(u.subarray(h/2,y));if(!at(L,u.subarray(y,y+32)))throw new Error("invalid secretKey: hash check failed");const[U,x,f,m]=a.decode(u),w=t.decrypt(l,U),$=s.create().update(w).update(f).digest(),k=$.subarray(0,32),v=t.encrypt(x,w,$.subarray(32,64)),B=at(l,v),b=r.create({dkLen:32}).update(m).update(l).digest();return ge(w,v,B?b:k),B?k:b}}}function mr(e,t,n){return en.create({dkLen:e}).update(t).update(new Uint8Array([n])).digest()}const yr={HASH256:Wt,HASH512:Ee,KDF:en,XOF:rr,PRF:mr},gt=fr({...yr,...cr[1024]}),be=BigInt(8),Ye=BigInt(255);function Re(e){e=BigInt(e);const t=[Number(e&Ye)];for(e>>=be;e>0;e>>=be)t.unshift(Number(e&Ye));return t.unshift(t.length),new Uint8Array(t)}function pr(e){e=BigInt(e);const t=[Number(e&Ye)];for(e>>=be;e>0;e>>=be)t.unshift(Number(e&Ye));return t.push(t.length),new Uint8Array(t)}function gr(e,t){return e.dkLen===void 0?t:e.dkLen}const wr=(e,t="")=>e===void 0?on:(te(e,void 0,t),e),sn=(e,t)=>new Uint8Array((t-e%t)%t);function Er(e,t={}){if(!t||t.personalization===void 0&&t.NISTfn===void 0)return e;const n=Re(e.blockLen),s=t.NISTfn===void 0?on:zn(t.NISTfn),r=Re(be*BigInt(s.length)),o=wr(t.personalization,"personalization"),i=Re(be*BigInt(o.length));if(!s.length&&!o.length)return e;e.suffix=4,e.update(n).update(r).update(s).update(i).update(o);let a=n.length+r.length+s.length+i.length+o.length;return e.update(sn(a,e.blockLen)),e}class br extends Qe{constructor(t,n,s,r,o={}){super(t,31,n,s),Er(this,{NISTfn:"KMAC",personalization:o.personalization}),te(r,void 0,"key");const i=Re(this.blockLen),a=Re(be*BigInt(r.length));this.update(i).update(a).update(r);const c=i.length+a.length+r.length;this.update(sn(c,this.blockLen))}finish(){this.finished||this.update(pr(this.enableXOF?0:be*BigInt(this.outputLen))),super.finish()}_cloneInto(t){return t||(t=Object.create(Object.getPrototypeOf(this),{}),t.state=this.state.slice(),t.blockLen=this.blockLen,t.state32=yt(t.state)),super._cloneInto(t)}clone(){return this._cloneInto()}}function vr(e,t,n=!1){const s=(r,o,i)=>s.create(r,i).update(o).digest();return s.create=(r,o={})=>new br(e,gr(o,t),n,r,o),s}const Be=vr(136,32),on=Uint8Array.of(),we={minEvents:100,mixOsEveryNEvents:32,maxCollectionMs:3e4,directionBuckets:8,maxTimeDeltaMs:1e3,seedLength:64},Y=we.seedLength;function Ir(){const e=crypto.getRandomValues(new Uint8Array(Y)),t=crypto.getRandomValues(new Uint8Array(Y));let n=!0;for(let s=0;s<e.length;s++)if(e[s]!==t[s]){n=!1;break}if(n)throw new Error("CSPRNG health check failed: consecutive outputs are identical");return e}function kr(e,t,n,s){const o=Math.atan2(t,e)+Math.PI,i=Math.floor(o/(2*Math.PI)*we.directionBuckets)%we.directionBuckets,a=Math.min(255,Math.floor(Math.hypot(e,t))),c=Math.min(we.maxTimeDeltaMs,Math.max(0,n)),d=new Uint8Array(6);return d[0]=1,d[1]=i&255,d[2]=a&255,d[3]=c&255,d[4]=c>>8&255,d[5]=s&255,d}function Sr(e,t,n,s,r){const o=t+n+(r?1:0)&255,i=Math.min(we.maxTimeDeltaMs,Math.max(0,s)),a=new Uint8Array(5);return a[0]=2,a[1]=o,a[2]=i&255,a[3]=i>>8&255,a[4]=n&255,a}function Lr(e,t,n){const s=Math.floor(e/100)&255,r=Math.floor(t/100)&255,o=Math.min(we.maxTimeDeltaMs,Math.max(0,n)),i=new Uint8Array(5);return i[0]=3,i[1]=s,i[2]=r,i[3]=o&255,i[4]=o>>8&255,i}class an{constructor(){this.events=[],this.isCollecting=!1,this.startTime=0,this.listeners=[],this.entropyBuffer=new Uint8Array(0),this.entropyState=crypto.getRandomValues(new Uint8Array(64)),this.lastEventTime=0,this.screenInfo=null,this.eventCount=0,this.processingQueue=[],this.isProcessing=!1,this.lastMouseX=0,this.lastMouseY=0,this.mouseInitialized=!1}async startCollection(){if(this.isCollecting)throw new Error("Entropy collection already in progress");return new Promise((t,n)=>{this.isCollecting=!0,this.startTime=performance.now(),this.lastEventTime=this.startTime,this.events=[],this.entropyBuffer=new Uint8Array(0),this.screenInfo={width:window.innerWidth,height:window.innerHeight,screenX:window.screenX,screenY:window.screenY,colorDepth:window.screen.colorDepth,pixelDepth:window.screen.pixelDepth},this.setupEventListeners();const s=setTimeout(()=>{console.log("âš ï¸ Entropy collection timeout reached, generating final seed..."),this.stopCollection();const o=this.generateFinalSeed();console.log(`Timeout final seed length: ${o.length} bytes`),t(o)},we.maxCollectionMs),r=()=>{this.events.length>=we.minEvents?(clearTimeout(s),this.stopCollection(),t(this.generateFinalSeed())):this.isCollecting&&setTimeout(r,100)};setTimeout(r,100)})}stopCollection(){this.isCollecting=!1,this.removeEventListeners()}setupEventListeners(){const t=o=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime;if(!this.mouseInitialized){this.lastMouseX=o.clientX,this.lastMouseY=o.clientY,this.mouseInitialized=!0,this.lastEventTime=i;return}const c=o.clientX-this.lastMouseX,d=o.clientY-this.lastMouseY;if(c===0&&d===0)return;const l=kr(c,d,a,o.buttons);this.lastMouseX=o.clientX,this.lastMouseY=o.clientY,this.lastEventTime=i,this.processEventAsync(l),this.events.push({type:"mouse",timestamp:i})},n=o=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime,c=Sr(o.key,o.keyCode,o.location,a,o.repeat);this.lastEventTime=i,this.processEventAsync(c),this.events.push({type:"key",timestamp:i})},s=()=>{if(!this.isCollecting)return;const o=performance.now(),i=o-this.lastEventTime,a=Lr(window.innerWidth,window.innerHeight,i);this.lastEventTime=o,this.processEventAsync(a),this.events.push({type:"window",timestamp:o})},r=o=>{if(!this.isCollecting)return;const i=performance.now(),a=i-this.lastEventTime,c=o.touches[0];if(c){const d=Math.floor(c.clientX/50)&255,l=Math.floor(c.clientY/50)&255,u=new Uint8Array(6);u[0]=4,u[1]=d,u[2]=l,u[3]=Math.min(255,Math.floor(c.force*255))&255,u[4]=a&255,u[5]=a>>8&255,this.lastEventTime=i,this.processEventAsync(u),this.events.push({type:"touch",timestamp:i})}};document.addEventListener("mousemove",t,{passive:!0}),document.addEventListener("keydown",n,{passive:!0}),document.addEventListener("keyup",n,{passive:!0}),window.addEventListener("resize",s,{passive:!0}),window.addEventListener("focus",s,{passive:!0}),window.addEventListener("blur",s,{passive:!0}),document.addEventListener("touchmove",r,{passive:!0}),this.listeners=[{element:document,event:"mousemove",handler:t},{element:document,event:"keydown",handler:n},{element:document,event:"keyup",handler:n},{element:window,event:"resize",handler:s},{element:window,event:"focus",handler:s},{element:window,event:"blur",handler:s},{element:document,event:"touchmove",handler:r}]}removeEventListeners(){this.listeners.forEach(({element:t,event:n,handler:s})=>{t.removeEventListener(n,s)}),this.listeners=[]}processEventAsync(t){this.processingQueue.push(t),this.isProcessing||(this.isProcessing=!0,setTimeout(()=>this.processQueue(),0))}async processQueue(){for(;this.processingQueue.length>0;){const t=this.processingQueue.shift();await this.processEventSummary(t),this.processingQueue.length>0&&await new Promise(n=>setTimeout(n,0))}this.isProcessing=!1}async processEventSummary(t){if(this.eventCount++,this.eventCount%we.mixOsEveryNEvents===0){const i=crypto.getRandomValues(new Uint8Array(32)),a=new Uint8Array(this.entropyState.length+i.length);a.set(this.entropyState,0),a.set(i,this.entropyState.length),this.entropyState=Ee(a)}const n=crypto.getRandomValues(new Uint8Array(16)),s=new Uint8Array(t.length+n.length);s.set(t,0),s.set(n,t.length);const r=Ee(s),o=new Uint8Array(this.entropyState.length+r.length);o.set(this.entropyState,0),o.set(r,this.entropyState.length),this.entropyState=Ee(o),t.fill(0)}generateFinalSeed(){this.processingQueue.length>0&&(this.processingQueue.forEach(c=>{this.processEventSummary(c)}),this.processingQueue=[]);const t=crypto.getRandomValues(new Uint8Array(32)),n=new Uint8Array(this.entropyState.length+t.length);n.set(this.entropyState,0),n.set(t,this.entropyState.length),this.entropyState=Ee(n);const s=new Uint8Array(4);s[0]=0;const r=Be(this.entropyState,s,void 0,{customization:"quantum-vault:final-seed:v1"});s[0]=1;const o=Be(this.entropyState,s,void 0,{customization:"quantum-vault:final-seed:v1"}),i=new Uint8Array(Y);i.set(r,0),i.set(o,32);const a=new Uint8Array(this.entropyState.length+i.length);return a.set(this.entropyState,0),a.set(i,this.entropyState.length),this.entropyState=Ee(a),i}getProgress(){const t=this.events.length,n=we.minEvents,s=Math.min(100,Math.round(t/n*100)),r=this.estimateEntropyBits();return{collected:t,required:n,percentage:s,queueSize:this.processingQueue.length,estimatedEntropyBits:r,isCollecting:this.isCollecting}}estimateEntropyBits(){if(this.events.length===0)return 0;const t={mouse:0,key:0,window:0,touch:0};this.events.forEach(i=>{i.type in t&&t[i.type]++});const n=this.events.length;let s=0;Object.values(t).forEach(i=>{if(i>0){const a=i/n;s-=a*Math.log2(a)}});const r=this.estimateTimingEntropy(),o=(s+r)*this.events.length*.1;return Math.min(o,512)}estimateTimingEntropy(){if(this.events.length<2)return 0;const t=[];for(let i=1;i<this.events.length;i++){const a=this.events[i].timestamp-this.events[i-1].timestamp;t.push(a)}const n=50,s=new Map;t.forEach(i=>{const a=Math.floor(i/n);s.set(a,(s.get(a)||0)+1)});let r=0;const o=t.length;return s.forEach(i=>{const a=i/o;r-=a*Math.log2(a)}),r}}function Br(e,t=new Uint8Array(0)){if(e.length!==Y)throw new Error(`Base seed must be ${Y} bytes`);if(t.length===0)return e;const n=Be(e,t,void 0,{customization:"quantum-vault:entropy-mix:v1"}),s=new Uint8Array(Y);s.set(n,0);const r=crypto.getRandomValues(new Uint8Array(32));if(s.set(r,32),s.length===Y)return s;if(s.length<Y){const o=new Uint8Array(Y);o.set(s,0);const i=crypto.getRandomValues(new Uint8Array(Y-s.length));return o.set(i,s.length),o}else return s.slice(0,Y)}async function xr(e=!1){const t=Ir();if(!e)return{seed:t,hasUserEntropy:!1};try{const s=await new an().startCollection();console.log(`Entropy collected: ${s.length} bytes`);const r=Br(t,s);return r.length!==Y&&console.warn(`Mixed seed length mismatch: ${r.length}, expected ${Y}`),{seed:r,hasUserEntropy:s.length>0}}catch(n){return console.warn("User entropy collection failed, using secure random seed:",n.message),console.log(`Fallback seed length: ${t.length} bytes (expected: ${Y})`),{seed:t,hasUserEntropy:!1}}}function $r(e){if(!(e instanceof Uint8Array))throw new Error("Seed must be Uint8Array");if(e.length!==Y)throw new Error(`Seed must be exactly ${Y} bytes`)}const wt=e=>Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("");function _e(e){if(e instanceof Uint8Array)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("Expected ArrayBuffer or Uint8Array")}function Et(e){const t=typeof e=="string"?e:String(e||"");return t.length<12?t:`${t.slice(0,6)}...${t.slice(-6)}`}async function ee(e){return new Uint8Array(await e.arrayBuffer())}function se(e,t){const n=document.createElement("a");n.href=URL.createObjectURL(e),n.download=t,n.style.display="none",document.body.appendChild(n),n.click(),URL.revokeObjectURL(n.href),n.remove()}function oe(e){document.querySelectorAll("button").forEach(t=>{t.disabled=e})}function cn(){return new Date().toLocaleTimeString()}function ln(){return new Date().toISOString().slice(0,19).replace(/:/g,"-")}function We(e){return!Number.isFinite(e)||e<0?"0 B":e<1024?`${e} B`:e<1024*1024?`${(e/1024).toFixed(1)} KB`:e<1024*1024*1024?`${(e/(1024*1024)).toFixed(2)} MB`:`${(e/(1024*1024*1024)).toFixed(2)} GB`}function bt(e,t){return!(t<2||e<=t||(e-t)%2!==0||e<5)}function dn(e,t){const n=e-t;return t+n/2}function Ar(e,t){if(!(e instanceof Uint8Array)||!(t instanceof Uint8Array)||e.length!==t.length)return!1;let n=0;for(let s=0;s<e.length;s++)n|=e[s]^t[s];return n===0}function Ae(e,t){if(e===t)return!0;if(!(e instanceof Uint8Array)||!(t instanceof Uint8Array)||e.length!==t.length)return!1;let n=0;for(let s=0;s<e.length;s++)n|=e[s]^t[s];return n===0}async function Mr(e={}){const{collectUserEntropy:t=!1,customSeed:n=null}=e;let s,r;if(n)$r(n),s=n,r={hasUserEntropy:!1,source:"custom"};else{const i=await xr(t);s=i.seed,r={hasUserEntropy:i.hasUserEntropy,source:i.hasUserEntropy?"mixed":"secure-random"}}const o=gt.keygen(s);return s.fill(0),{publicKey:_e(o.publicKey),secretKey:_e(o.secretKey),seedInfo:r}}async function Cr(e){const t=await gt.encapsulate(e),n=t.cipherText||t.ciphertext||t.ct,s=t.sharedSecret||t.ss;if(!n||!s)throw new Error("KEM encapsulation failed: result is missing required fields.");return{encapsulatedKey:_e(n),sharedSecret:_e(s)}}async function Ur(e,t){const n=await gt.decapsulate(e,t),s=_e(n);if(!s||s.length===0)throw new Error("KEM decapsulation failed. The key may be incorrect or the ciphertext corrupted.");return s}const Me=new TextEncoder().encode("QVv1"),Nr=38,xe=8*1024*1024,Tr="quantum-vault:kdf:v1",Kr="quantum-vault:chunk-iv:v1",He=32,dt="QVv1-4-0",Ue="QVqcont-3",Ze=12;async function un(e,t,n,s){if(typeof s!="string"||s.length===0)throw new Error("KMAC customization domain is required");const r=new Uint8Array(t.length+n.length);r.set(t,0),r.set(n,t.length);const i=Be(e,r,32,{customization:s}),a=Be(i,new Uint8Array([1]),32,{customization:"quantum-vault:kenc:v1"}),c=Be(i,new Uint8Array([2]),32,{customization:"quantum-vault:kiv:v1"}),d=await crypto.subtle.importKey("raw",a.buffer,{name:"AES-GCM"},!1,["encrypt","decrypt"]);return{Kraw:i,Kenc:a,Kiv:c,aesKey:d}}function hn(e,t,n){const s=new Uint8Array(e.length+8);s.set(e,0);const r=new DataView(s.buffer);return r.setUint32(s.length-8,t,!1),r.setUint32(s.length-4,n,!1),s}function fn(e,t,n,s){if(typeof s!="string"||s.length===0)throw new Error("IV customization domain is required");const r=new Uint8Array(4);new DataView(r.buffer).setUint32(0,n,!1);const o=new Uint8Array(t.length+r.length);return o.set(t,0),o.set(r,t.length),Be(e,o,16,{customization:s}).slice(0,12)}async function Pt(e,t,n,s){if(n.length!==Ze)throw new Error(`IV must be ${Ze} bytes for AES-GCM`);const r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,additionalData:s,tagLength:128},e,t);return new Uint8Array(r)}async function qt(e,t,n,s){if(n.length!==Ze)throw new Error(`IV must be ${Ze} bytes for AES-GCM`);const r=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,additionalData:s,tagLength:128},e,t);return new Uint8Array(r)}function Fr(e){return e>xe}function mn(e){return Math.ceil(e/xe)}function ut(...e){e.forEach(t=>{t instanceof Uint8Array&&t.fill(0)})}function yn(e){if(!(e instanceof Uint8Array)||e.length!==32)throw new Error("Kenc must be 32-byte Uint8Array");return Wt(e)}function Or(e,t){const n=yn(e);return Ar(n,t)}function Pr(e){const t=new Uint8Array(2);return new DataView(t.buffer).setUint16(0,e,!1),t}function qr(e){const t=new Uint8Array(4);return new DataView(t.buffer).setUint32(0,e,!1),t}function pn({encapsulatedKey:e,containerNonce:t,kdfSalt:n,metaBytes:s,keyCommitment:r=null}){if(!(e instanceof Uint8Array))throw new Error("encapsulatedKey must be Uint8Array");if(!(t instanceof Uint8Array)||t.length!==12)throw new Error("containerNonce must be 12-byte Uint8Array");if(!(n instanceof Uint8Array)||n.length!==16)throw new Error("kdfSalt must be 16-byte Uint8Array");if(!(s instanceof Uint8Array))throw new Error("metaBytes must be Uint8Array");if(s.length<=0||s.length>65535)throw new Error(`Invalid metaBytes length: ${s.length}`);if(r!==null){if(!(r instanceof Uint8Array))throw new Error("keyCommitment must be Uint8Array or null");if(r.length!==He)throw new Error(`keyCommitment must be ${He} bytes`)}const o=qr(e.length),i=Pr(s.length),a=r||new Uint8Array(0),c=new Uint8Array(Me.length+o.length+e.length+t.length+n.length+i.length+s.length+a.length);let d=0;return c.set(Me,d),d+=Me.length,c.set(o,d),d+=o.length,c.set(e,d),d+=e.length,c.set(t,d),d+=t.length,c.set(n,d),d+=n.length,c.set(i,d),d+=i.length,c.set(s,d),d+=s.length,a.length>0&&c.set(a,d),c}function gn(e,t={}){const{maxMetaLen:n=4096}=t;if(!(e instanceof Uint8Array))throw new Error("containerBytes must be Uint8Array");if(e.length<Nr)throw new Error(`File is too small to be a valid container (size: ${e.length} B).`);const s=new DataView(e.buffer,e.byteOffset,e.byteLength);let r=0;const o=e.subarray(r,r+Me.length);if(!Ae(o,Me))throw new Error("Invalid file format (magic bytes mismatch).");r+=Me.length;const i=s.getUint32(r,!1);if(r+=4,i<=0)throw new Error(`Invalid encapsulated key length ${i}.`);if(i>e.length)throw new Error(`Invalid encapsulated key length ${i}: exceeds container size.`);if(r+i>e.length)throw new Error("Incomplete container: encapsulated key length exceeds file size.");const a=e.subarray(r,r+i);if(r+=i,r+12+16+2>e.length)throw new Error("Incomplete container: header is truncated.");const c=e.subarray(r,r+12);r+=12;const d=e.subarray(r,r+16);r+=16;const l=s.getUint16(r,!1);if(r+=2,l<=0||l>n)throw new Error(`Invalid metadata length: ${l}. Must be between 1 and ${n}.`);if(r+l>e.length)throw new Error("Incomplete container: metadata length exceeds file size.");const u=e.subarray(r,r+l);let h;try{h=JSON.parse(new TextDecoder().decode(u))}catch(U){throw new Error(`Invalid metadata JSON: ${U?.message||U}`)}if(r+=l,!h||typeof h!="object")throw new Error("Invalid metadata JSON: expected object");if(h.fmt!==dt)throw new Error(`Unsupported container format: expected ${dt}, got ${h.fmt??"unknown"}`);if(typeof h?.aead_mode!="string"||h.aead_mode.length===0)throw new Error("Invalid metadata: missing aead_mode");if(!h.domainStrings||typeof h.domainStrings.kdf!="string"||typeof h.domainStrings.iv!="string")throw new Error("Invalid metadata: missing domainStrings.kdf/domainStrings.iv");if(h.payloadLength!=null&&(!Number.isInteger(h.payloadLength)||h.payloadLength<=0))throw new Error("Invalid metadata: payloadLength must be a positive integer");if(h.chunkCount!=null&&(!Number.isInteger(h.chunkCount)||h.chunkCount<=0))throw new Error("Invalid metadata: chunkCount must be a positive integer");if(h.chunkSize!=null&&(!Number.isInteger(h.chunkSize)||h.chunkSize<=0))throw new Error("Invalid metadata: chunkSize must be a positive integer");let y=null;if(h?.hasKeyCommitment){if(r+He>e.length)throw new Error("Incomplete container: key commitment missing.");y=e.subarray(r,r+He),r+=He}if(r>=e.length)throw new Error("Invalid container: ciphertext is missing");return{header:e.subarray(0,r),offset:r,encapsulatedKey:a,containerNonce:c,kdfSalt:d,metaBytes:u,metadata:h,storedKeyCommitment:y}}async function wn(e={}){return await Mr(e)}async function z(e){return wt(Ee(e))}async function ht(e,t,n){const{encapsulatedKey:s,sharedSecret:r}=await Cr(t),o=crypto.getRandomValues(new Uint8Array(12)),i=crypto.getRandomValues(new Uint8Array(16)),a={originalFilename:n||null,timestamp:new Date().toISOString(),fileHash:await z(e),originalLength:e.length},c=new TextEncoder().encode(JSON.stringify(a)),d=4+c.length+e.length,l=new Uint8Array(d);new DataView(l.buffer).setUint32(0,c.length,!1),l.set(c,4),l.set(e,4+c.length);const u=Fr(d),h=u?mn(d):1,y={kdf:Tr,iv:Kr},L={KEM:"ML-KEM-1024",KDF:"KMAC256",AEAD:"AES-256-GCM",aead_mode:u?"per-chunk-aead":"single-container-aead",iv_strategy:u?"kmac-derive-v1":"single-iv",fmt:dt,hasKeyCommitment:!0,payloadFormat:"wrapped-v1",payloadLength:d,chunkSize:xe,chunkCount:h,domainStrings:y},U=new TextEncoder().encode(JSON.stringify(L)),{Kraw:x,Kenc:f,Kiv:m,aesKey:w}=await un(r,i,U,y.kdf),$=yn(f),k=pn({encapsulatedKey:s,containerNonce:o,kdfSalt:i,metaBytes:U,keyCommitment:$});try{let v;if(u){const B=[];let b=0,I=0;for(;b<l.length;){const H=Math.min(xe,l.length-b),V=l.subarray(b,b+H),ae=fn(m,o,I,y.iv),W=hn(k,I,H),de=await Pt(w,V,ae,W);B.push(de),I++,b+=H}const N=B.reduce((H,V)=>H+V.length,0),M=new Uint8Array(N);let F=0;for(const H of B)M.set(H,F),F+=H.length;v=new Blob([k,M],{type:"application/octet-stream"})}else{const B=await Pt(w,l,o,k);v=new Blob([k,B],{type:"application/octet-stream"})}return v}finally{l.fill(0),ut(r,x,f,m)}}async function En(e,t){const{header:n,offset:s,encapsulatedKey:r,containerNonce:o,kdfSalt:i,metaBytes:a,metadata:c,storedKeyCommitment:d}=gn(e);if(r.length!==1568)throw new Error(`Invalid encapsulated key length ${r.length}. Expected 1568 for ML-KEM-1024.`);const l=e.subarray(s),u=await Ur(r,t),h=c.domainStrings;if(!h||typeof h.kdf!="string"||typeof h.iv!="string")throw new Error("Container metadata is missing valid domainStrings");const{Kraw:y,Kenc:L,Kiv:U,aesKey:x}=await un(u,i,a,h.kdf);if(d&&!Or(L,d))throw ut(u,y,L,U),new Error("Key commitment verification failed. Container may be corrupted or tampered with.");try{let f;const m=c.payloadLength||c.originalLength;if(c.aead_mode==="per-chunk-aead"){const k=c.chunkCount||mn(m),v=[];let B=0;for(let N=0;N<k;N++){const M=Math.min(xe,m-N*xe),F=M+16,H=l.subarray(B,B+F),V=fn(U,o,N,h.iv),ae=hn(n,N,M),W=await qt(x,H,V,ae);v.push(W),B+=F}if(B!==l.length)throw new Error("Encrypted payload has trailing or truncated chunk data");const b=v.reduce((N,M)=>N+M.length,0);f=new Uint8Array(b);let I=0;for(const N of v)f.set(N,I),I+=N.length}else if(c.aead_mode==="single-container-aead")f=await qt(x,l,o,n);else throw new Error(`Unsupported AEAD mode: ${c.aead_mode??"unknown"}`);let w,$={...c};if(c.payloadFormat==="wrapped-v1"){const v=new DataView(f.buffer,f.byteOffset,f.byteLength).getUint32(0,!1);if(v<=0||v>f.length-4)throw new Error("Invalid private metadata length in decrypted payload");const B=f.subarray(4,4+v),b=JSON.parse(new TextDecoder().decode(B));w=f.subarray(4+v),$={...c,...b}}else throw new Error(`Unsupported payload format: ${c.payloadFormat??"unknown"}`);return{decryptedBlob:new Blob([w]),metadata:$}}finally{ut(u,y,L,U)}}const qe=new TextEncoder().encode("QVB1"),bn=1;function Rr(e){const t=7+e.reduce((o,i)=>o+2+i.nameBytes.length+4+i.bytes.length,0),n=new Uint8Array(t),s=new DataView(n.buffer);let r=0;n.set(qe,r),r+=4,n[r]=bn,r+=1,s.setUint16(r,e.length,!1),r+=2;for(const o of e)s.setUint16(r,o.nameBytes.length,!1),r+=2,n.set(o.nameBytes,r),r+=o.nameBytes.length,s.setUint32(r,o.bytes.length,!1),r+=4,n.set(o.bytes,r),r+=o.bytes.length;return n}async function vn(e){const t=new TextEncoder,n=[];for(const r of e){const o=await ee(r),i=t.encode(r.name);if(i.length===0||i.length>65535)throw new Error(`Invalid filename length for bundle entry: "${r.name}"`);if(o.length>4294967295)throw new Error(`File is too large for bundle format: "${r.name}"`);n.push({name:r.name,nameBytes:i,bytes:o})}return{bundleName:`bundle-${ln()}.qvpack`,bundleBytes:Rr(n),fileCount:n.length}}function vt(e){return e instanceof Uint8Array&&e.length>=7&&e[0]===qe[0]&&e[1]===qe[1]&&e[2]===qe[2]&&e[3]===qe[3]}function In(e){if(!vt(e))throw new Error("Not a valid bundle payload");const t=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=4;const s=e[n];if(n+=1,s!==bn)throw new Error(`Unsupported bundle version: ${s}`);if(n+2>e.length)throw new Error("Bundle is truncated before entry count");const r=t.getUint16(n,!1);if(n+=2,r<=0)throw new Error("Bundle contains no files");const o=new TextDecoder,i=[];for(let a=0;a<r;a++){if(n+2>e.length)throw new Error("Bundle is truncated at name length");const c=t.getUint16(n,!1);if(n+=2,c<=0)throw new Error(`Bundle entry ${a} has invalid filename length`);if(n+c>e.length)throw new Error(`Bundle entry ${a} filename is truncated`);const d=o.decode(e.subarray(n,n+c));if(n+=c,n+4>e.length)throw new Error(`Bundle entry ${a} is missing payload length`);const l=t.getUint32(n,!1);if(n+=4,n+l>e.length)throw new Error(`Bundle entry ${a} payload is truncated`);const u=e.subarray(n,n+l);n+=l,i.push({name:d,bytes:u})}if(n!==e.length)throw new Error("Bundle has trailing bytes");return i}function g(e,t={}){const{elementId:n="log",isLiteMode:s=!0}=t,r=document.getElementById(n);if(!r)return;const o=document.createElement("span");o.textContent=`[${cn()}] ${e}`,r.appendChild(o),r.appendChild(document.createTextNode(`
`)),r.scrollTop=r.scrollHeight}function P(e,t={}){const{elementId:n="log",isLiteMode:s=!0}=t,r=document.getElementById(n);if(!r)return;const o=e&&e.message?e.message:typeof e=="string"?e:String(e),i=document.createElement("span");i.className="error",i.textContent=`[${cn()}] ERROR: ${o}`,r.appendChild(i),r.appendChild(document.createTextNode(`
`)),r.scrollTop=r.scrollHeight}function Se(e,t,n={}){const{isLiteMode:s=!0,elementId:r="log"}=n,o=s?Et(t):t;g(`${e}: ${o}`,{elementId:r,isLiteMode:s})}function Hr(e,t,n,s={}){const{isLiteMode:r=!0,elementId:o="log"}=s;r?(g("Lite Mode: ML-KEM keys generated automatically",{elementId:o,isLiteMode:r}),Se("Private Key",e,{isLiteMode:r,elementId:o}),Se("Public Key",t,{isLiteMode:r,elementId:o})):(g("Pro Mode: ML-KEM-1024 key pair generated",{elementId:o,isLiteMode:r}),g(`Entropy source: ${n.source}`,{elementId:o,isLiteMode:r}),n.hasUserEntropy&&g("âœ… User entropy successfully collected and mixed",{elementId:o,isLiteMode:r}),Se("Private Key Hash",e,{isLiteMode:r,elementId:o}),Se("Public Key Hash",t,{isLiteMode:r,elementId:o}))}function Dr(e,t,n,s={}){const{isLiteMode:r=!0,elementId:o="log"}=s;r?(g(`â³ Processing: ${e} (${t} bytes)`,{elementId:o,isLiteMode:r}),Se(`âœ… Encrypted: ${e} (hash)`,n,{isLiteMode:r,elementId:o})):(g(`â³ Encrypting file: ${e}`,{elementId:o,isLiteMode:r}),g(`File size: ${t.toLocaleString()} bytes`,{elementId:o,isLiteMode:r}),Se("File hash (SHA3-512)",n,{isLiteMode:r,elementId:o}),g("âœ… File encryption completed",{elementId:o,isLiteMode:r}))}function zr(e,t,n,s={}){const{isLiteMode:r=!0,elementId:o="log"}=s;r?(g(`Creating shards with n=${t.n}, k=${t.k}, m=${t.m}, t=${t.t}`,{elementId:o,isLiteMode:r}),g(`Effective threshold: ${t.t} shards (${Math.round(t.t/t.n*100)}%)`,{elementId:o,isLiteMode:r}),g(`âœ… Created ${e} shards for ${n}`,{elementId:o,isLiteMode:r})):(g("Reed-Solomon Configuration:",{elementId:o,isLiteMode:r}),g(`  Total shards (n): ${t.n}`,{elementId:o,isLiteMode:r}),g(`  Data shards (k): ${t.k}`,{elementId:o,isLiteMode:r}),g(`  Parity shards (m): ${t.m}`,{elementId:o,isLiteMode:r}),g(`  Shamir threshold (t): ${t.t}`,{elementId:o,isLiteMode:r}),g(`Shards created: ${e} for file "${n}"`,{elementId:o,isLiteMode:r}),g("âœ… Shard creation completed successfully",{elementId:o,isLiteMode:r}))}function _r(e,t,n={}){const{isLiteMode:s=!0,elementId:r="log"}=n;s?g(`Restoring ${Et(t)} container from ${e} shard files...`,{elementId:r,isLiteMode:s}):(g("Restoration Process Started",{elementId:r,isLiteMode:s}),g(`Input shards: ${e}`,{elementId:r,isLiteMode:s}),Se("Container ID",t,{isLiteMode:s,elementId:r}))}function Vr(e){if(!e.includes("."))return!/^[a-f0-9]+$/i.test(e);const t=e.split(".")[0];return/^[a-f0-9]+$/i.test(t)?!1:/[a-zA-Z]/.test(t)||/\s/.test(t)||/[-_]/.test(t)}function Qr(e,t,n,s,r={}){const{isLiteMode:o=!0,elementId:i="log"}=r;if(o){const a=Vr(e)?e:e.includes(".")?`${Et(e.split(".")[0])}.${e.split(".").pop()}`:e;g(`âœ… Restoration complete - files have been decrypted and restored. Original file: ${a} (${t} bytes) - Encrypted on: ${n}`,{elementId:i,isLiteMode:o})}else g("âœ… Container restoration completed successfully",{elementId:i,isLiteMode:o}),g(`Restored file: ${e}`,{elementId:i,isLiteMode:o}),g(`File size: ${t.toLocaleString()} bytes`,{elementId:i,isLiteMode:o}),g(`Original encryption time: ${n}`,{elementId:i,isLiteMode:o}),g("âœ… File integrity verification passed",{elementId:i,isLiteMode:o})}async function jr(e){const t=new TextDecoder;let n=new Uint8Array(await e.slice(0,Math.min(e.size,16384)).arrayBuffer()),s=new DataView(n.buffer,n.byteOffset,n.byteLength);const r=async y=>{if(n.length>=y)return;const L=Math.min(e.size,y);if(n=new Uint8Array(await e.slice(0,L).arrayBuffer()),s=new DataView(n.buffer,n.byteOffset,n.byteLength),n.length<y)throw new Error("Shard header is truncated")};if(await r(6),t.decode(n.subarray(0,4))!=="QVC1")throw new Error("Invalid shard file");let i=4;const a=s.getUint16(i,!1);if(a<=0)throw new Error("Invalid shard metadata length");i+=2,await r(i+a);const c=JSON.parse(t.decode(n.subarray(i,i+a)));if(c?.alg?.fmt!==Ue)throw new Error(`Unsupported shard format: expected ${Ue}`);i+=a,await r(i+4);const d=s.getUint32(i,!1);if(d<=0)throw new Error("Invalid encapsulated key length");i+=4,await r(i+d+12+16+2),i+=d+12+16;const l=s.getUint16(i,!1);i+=2,await r(i+l+1+2),i+=l,await r(i+1);const u=n[i];if(i+=1,u>32)throw new Error(`Invalid key commitment length ${u}`);await r(i+u+2),i+=u,await r(i+2);const h=s.getUint16(i,!1);if(!Number.isInteger(c?.t)||!Number.isInteger(c?.n))throw new Error("Shard metadata is missing n/t");return{containerId:c.containerId,n:c.n,t:c.t,shardIndex:h}}async function kn(e){if(!e.length)return{state:"empty",ready:!1};const t=[];let n=0;for(const u of e)try{t.push(await jr(u))}catch{n++}if(!t.length)return{state:"unknown",ready:!1,message:"Unable to read shard metadata from selected files."};if(new Set(t.map(u=>u.containerId)).size!==1)return{state:"invalid",ready:!1,message:"Selected shards belong to different containers."};const r=t[0];if(typeof r.containerId!="string"||r.containerId.length===0)return{state:"unknown",ready:!1,message:"Shard metadata is missing container identity."};if(!Number.isInteger(r.n)||!Number.isInteger(r.t)||r.t<2)return{state:"unknown",ready:!1,message:"Shard metadata does not contain a valid restore threshold."};if(t.some(u=>u.n!==r.n||u.t!==r.t))return{state:"invalid",ready:!1,message:"Shard metadata mismatch (n/t differs between files)."};const a=new Set(t.map(u=>u.shardIndex)).size,c=t.length-a,d=a>=r.t;let l=d?`Ready: ${a}/${r.n} unique shards selected (need >=${r.t}).`:`Insufficient: ${a}/${r.n} unique shards selected (need >=${r.t}).`;return c>0&&(l+=` ${c} duplicate shard(s) ignored.`),n>0&&(l+=` ${n} unreadable file(s) ignored.`),{state:d?"sufficient":"insufficient",ready:d,message:l,threshold:r.t}}function Jr(e,t,n,s){if(s.state==="sufficient"){e.className="shards-status sufficient",t.textContent=s.message,n&&(n.disabled=!1);return}if(s.state==="insufficient"){e.className="shards-status insufficient",t.textContent=s.message,n&&(n.disabled=!0);return}if(s.state==="invalid"){e.className="shards-status invalid",t.textContent=s.message,n&&(n.disabled=!0);return}e.className="shards-status unknown",t.textContent=s.message||"Cannot determine restore threshold from selected files.",n&&(n.disabled=!0)}async function Sn({files:e,statusDiv:t,statusText:n,actionButton:s,isCurrent:r=()=>!0}){if(!t||!n)return;if(e.length===0){t.style.display="none",s&&(s.disabled=!0);return}t.style.display="block",t.className="shards-status unknown",n.textContent="Analyzing shard metadata...",s&&(s.disabled=!0);const i=await kn(e);r()&&Jr(t,n,s,i)}let Ge=!1,$e=null,Rt=0;function Gr(){const e=E=>document.getElementById(E),t=e("privKeyInput"),n=e("pubKeyInput"),s=e("dataFileInput");e("qencForQcontInput"),e("privKeyForQcontInput");const r=e("rsN"),o=e("rsK"),i=e("rsText"),a=e("rsRuleN"),c=e("rsRuleRange"),d=e("rsRuleEven"),l=e("rsSegData"),u=e("rsSegParity"),h=e("rsMarker"),y=e("buildQcontBtn"),L=e("qcontShardsInput"),U=e("restoreQcontBtn"),x=e("genKeyBtn"),f=e("encBtn"),m=e("decBtn"),w=e("proEncStrategyGroup"),$=e("proEncStrategyPerFile"),k=e("proEncryptionWarning");function v(){const E=e("proFilesList");if(!(!E||!s)){if(!s.files||s.files.length===0){E.style.display="none",w&&(w.style.display="none");return}E.innerHTML="";for(const S of s.files){const T=document.createElement("div");T.className="file-item",T.innerHTML=`<span class="file-name">ðŸ“„ ${S.name}</span><span class="file-size">${We(S.size)}</span>`,E.appendChild(T)}E.style.display="block",w&&(w.style.display=s.files.length>1?"block":"none")}}async function B(){const E=e("proShardsStatus"),S=e("proShardsStatusText");if(!E||!S||!L)return;const T=[...L.files||[]],K=++Rt;await Sn({files:T,statusDiv:E,statusText:S,actionButton:U,isCurrent:()=>K===Rt})}function b(){const E=!!n?.files?.[0],S=!!t?.files?.[0];if(f&&(f.disabled=!E),m&&(m.disabled=!S),!k)return;let T,K;!E&&!S?(T='Load keys in tab "1. Key Management": public key for encryption and private key for decryption.',K="warning"):E?S?(T="Keys are loaded. Encryption and decryption are available.",K="success"):(T='Decryption is blocked: load a private key in tab "1. Key Management".',K="warning"):(T='Encryption is blocked: load a public key in tab "1. Key Management".',K="warning"),k.className=`operation-warning ${K}`,k.innerHTML=`<small>${T}</small>`}function I(){return $?.checked?"per-file":"pack"}s?.addEventListener("change",v),L?.addEventListener("change",()=>{B()}),n?.addEventListener("change",b),t?.addEventListener("change",b);function N(E,S){E&&(E.classList.remove("ok","fail"),E.classList.add(S?"ok":"fail"))}function M(){if(!r||!o)return;const E=parseInt(r.value,10),S=parseInt(o.value,10),T=Number.isInteger(E),K=Number.isInteger(S),R=T&&E>=5,q=T&&K&&S>=2&&S<E,G=T&&K&&(E-S)%2===0,Q=R&&q&&G,D=T&&K?E-S:0,ne=Q?S+D/2:0;if(N(a,R),N(c,q),N(d,G),y&&(y.disabled=!Q),i)if(Q)i.textContent=`Total: n=${E}. Data: k=${S}. Parity: m=${D}. Threshold: t=${ne}. Need >= t shards to restore.`,i.classList.remove("warning","error");else{const me=[];!T||!K?me.push("enter numeric values for n and k"):(R||me.push("n must be >= 5"),q||me.push("require 2 <= k < n"),G||me.push("(n - k) must be even")),i.textContent=`Invalid configuration: ${me.join("; ")}.`,i.classList.add("warning")}const ce=T&&E>0?E:1,O=K?Math.max(0,Math.min(S,ce)):0,X=Math.max(0,ce-O),ue=O/ce*100,_=X/ce*100,C=Q?ne/E*100:0;l&&(l.style.width=`${Math.max(0,Math.min(100,ue))}%`),u&&(u.style.width=`${Math.max(0,Math.min(100,_))}%`),h&&(h.style.left=`${Math.max(0,Math.min(100,C))}%`);const he=document.getElementById("rsDataLabel"),Z=document.getElementById("rsParityLabel"),j=document.getElementById("rsMarkerLabel");he&&(he.textContent=K?`k=${S}`:"k=?"),Z&&(Z.textContent=T&&K?`m=${D}`:"m=?"),j&&(j.textContent=Q?`t=${ne}`:"t=?",j.style.left=`${Math.max(0,Math.min(100,C))}%`);const fe=document.getElementById("rsTicks");if(fe&&(fe.innerHTML="",T&&E>0&&E<=64))for(let me=0;me<=E;me++){const p=document.createElement("span");p.className="tick",p.style.left=`${me/E*100}%`,p.title=String(me),fe.appendChild(p)}const ve=l&&l.parentElement?l.parentElement:null;ve&&ve.classList&&ve.classList.toggle("rs-error",!Q)}[r,o].forEach(E=>E&&E.addEventListener("input",M)),document.addEventListener("DOMContentLoaded",M),M(),B(),b(),v();const F=e("advancedEntropyBtn"),H=e("entropyStatus"),V=e("entropyText"),ae=e("entropyBar");async function W(){if(!$e)try{H.style.display="block",V.textContent="Move mouse, type, resize window... Collecting entropy...",F.disabled=!0,F.textContent="ðŸŽ² Collecting...",$e=new an;const E=setInterval(()=>{if(!$e){clearInterval(E);return}const S=$e.getProgress();ae.style.width=`${S.percentage}%`,V.textContent=`Events: ${S.collected}/${S.required} (${S.percentage}%) | Queue: ${S.queueSize} | Est. Entropy: ${Math.round(S.estimatedEntropyBits)} bits`},200);await $e.startCollection(),clearInterval(E),Ge=!0,$e=null,V.textContent="âœ… Advanced entropy collected successfully! 64-byte seed ready.",ae.style.width="100%",F.textContent="âœ… Entropy Collected",F.style.backgroundColor="#28a745"}catch(E){g(`Entropy collection failed: ${E.message}`),V.textContent="âŒ Entropy collection failed - will use secure random only",F.disabled=!1,F.textContent="ðŸŽ² Collect Additional Entropy"}}F?.addEventListener("click",W),x?.addEventListener("click",async()=>{oe(!0);try{g("Generating ML-KEM-1024 key pair..."),g(Ge?"Using crypto.getRandomValues() + collected user entropy for enhanced security":"Using crypto.getRandomValues() with 64-byte seed (secure default)");const{secretKey:E,publicKey:S,seedInfo:T}=await wn({collectUserEntropy:Ge}),K=await z(E),R=await z(S);g(`Entropy source: ${T.source}${T.hasUserEntropy?" (enhanced with user entropy)":""}`),g(`Private Key: secretKey.qkey (${E.length} B) SHA3-512=${K}`),g(`Public Key: publicKey.qkey (${S.length} B) SHA3-512=${R}`),se(new Blob([E]),"secretKey.qkey"),se(new Blob([S]),"publicKey.qkey"),g("âœ… Keys generated and downloaded successfully."),Ge=!1,F&&(F.textContent="ðŸŽ² Collect Additional Entropy",F.style.backgroundColor="",F.disabled=!1),H&&(H.style.display="none")}catch(E){P(E)}finally{oe(!1),b(),M(),B()}}),f?.addEventListener("click",async()=>{if(!n?.files?.[0]){P("Please select a public key (.qkey).");return}if(!s?.files?.length){P("Please select file(s) to encrypt.");return}oe(!0);try{const E=await ee(n.files[0]),S=[...s.files],T=I();if(T==="pack"&&S.length>1){const K=S.reduce((O,X)=>O+X.size,0),{bundleName:R,bundleBytes:q,fileCount:G}=await vn(S);g(`Packing ${G} files (${We(K)}) into one container...`);const Q=await ht(q,E,R),D=await ee(Q),ne=await z(D),ce=`${R}.qenc`;se(Q,ce),g(`âœ… Bundle encrypted: ${ce} (${Q.size} B) SHA3-512=${ne}`)}else{T==="per-file"&&S.length>1&&g("Encrypting each selected file into a separate container...");for(const K of S){g(`Encrypting file ${K.name} (${K.size} B)...`);const R=await ee(K),q=await ht(R,E,K.name),G=await ee(q),Q=await z(G);se(q,`${K.name}.qenc`),g(`âœ… File encrypted: ${K.name}.qenc (${q.size} B) SHA3-512=${Q}`)}}}catch(E){P(E)}finally{oe(!1),b(),M(),B(),s.value="",v()}}),m?.addEventListener("click",async()=>{if(!t?.files?.[0]){P("Please select a private key (.qkey).");return}if(!s?.files?.length){P("Please select file(s) to decrypt (.qenc).");return}oe(!0);try{const E=await ee(t.files[0]);for(const S of s.files){if(!S.name.toLowerCase().endsWith(".qenc")){g(`Skipping file ${S.name} as it is not a .qenc container.`);continue}g(`Decrypting file ${S.name} (${S.size} B)...`);const T=await ee(S),K=await z(T);g(`Container hash: SHA3-512=${K}`);const{decryptedBlob:R,metadata:q}=await En(T,E),G=await ee(R),Q=await z(G);if(vt(G)){const D=In(G);for(const ne of D)se(new Blob([ne.bytes]),ne.name);g(`âœ… Bundle decrypted: extracted ${D.length} file(s) from ${S.name}`)}else{let D=q.originalFilename;D||(D=S.name.replace(/\.qenc$/i,"")),se(R,D),g(`âœ… File decrypted: ${D} (${R.size} B)`)}g(`Original file hash (from metadata): ${q.fileHash}`),g(`Hash of decrypted content: ${Q}`),q.fileHash===Q?g("Hashes match! File integrity verified."):P("WARNING: Hashes do NOT match! File may have been corrupted."),g(`Encrypted on (UTC): ${q.timestamp}`)}}catch(E){P(E)}finally{oe(!1),b(),M(),B(),s.value="",v()}});function de(){const E={proTabIdentity:"proViewIdentity",proTabEncryption:"proViewEncryption",proTabDistribution:"proViewDistribution",proTabRestore:"proViewRestore"};Object.keys(E).forEach(S=>{const T=document.getElementById(S);T&&T.addEventListener("click",()=>{Object.keys(E).forEach(R=>{const q=document.getElementById(R);q&&q.classList.remove("active")}),Object.values(E).forEach(R=>{const q=document.getElementById(R);q&&(q.style.display="none",q.classList.remove("active"))}),T.classList.add("active");const K=document.getElementById(E[S]);K&&(K.style.display="block",K.classList.add("active")),S==="proTabDistribution"&&setTimeout(()=>{r?.dispatchEvent(new Event("input"))},10)})})}de()}const Xr="modulepreload",Yr=function(e){return"/quantum-vault/"+e},Ht={},Ln=function(t,n,s){let r=Promise.resolve();if(n&&n.length>0){let c=function(d){return Promise.all(d.map(l=>Promise.resolve(l).then(u=>({status:"fulfilled",value:u}),u=>({status:"rejected",reason:u}))))};document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),a=i?.nonce||i?.getAttribute("nonce");r=c(n.map(d=>{if(d=Yr(d),d in Ht)return;Ht[d]=!0;const l=d.endsWith(".css"),u=l?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${u}`))return;const h=document.createElement("link");if(h.rel=l?"stylesheet":Xr,l||(h.as="script"),h.crossOrigin="",h.href=d,a&&h.setAttribute("nonce",a),document.head.appendChild(h),l)return new Promise((y,L)=>{h.addEventListener("load",y),h.addEventListener("error",()=>L(new Error(`Unable to preload CSS for ${d}`)))})}))}function o(i){const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=i,window.dispatchEvent(a),!a.defaultPrevented)throw i}return r.then(i=>{for(const a of i||[])a.status==="rejected"&&o(a.reason);return t().catch(o)})};async function Bn(e,t,n,s={}){const r=s.formatVersion||Ue;if(r!==Ue)throw new Error(`Unsupported shard format version: ${r}`);const{n:o,k:i}=n,a=o-i;if(i<2||o<=i)throw new Error("Invalid RS parameters: require 2 <= k < n");if(a%2!==0)throw new Error("n-k must be even");const{header:c,offset:d,encapsulatedKey:l,containerNonce:u,kdfSalt:h,metaBytes:y,metadata:L,storedKeyCommitment:U}=gn(e),x=L,f=U,m=e.subarray(d),w=x.domainStrings;if(!w||typeof w.kdf!="string"||typeof w.iv!="string")throw new Error("QENC metadata is missing valid domainStrings");const $=x.payloadLength||x.originalLength,k=await z(c),v=await z(e),B=i+a/2;if(B>o)throw new Error("Invalid threshold computed");const{splitSecret:b}=await Ln(async()=>{const{splitSecret:O}=await import("./sss-CX0r5NR3.js");return{splitSecret:O}},[]),I=await b(t,o,B),N=[];for(let O=0;O<o;O++)N.push(await z(I[O]));const M=Array.from({length:o},()=>[]),F=x.chunkSize||xe,H=x.aead_mode==="per-chunk-aead",V=H?x.chunkCount||Math.ceil($/F):1,ae=255;let W=0,de=0;for(let O=0;O<V;O++){let X;if(H){const fe=Math.min(F,$-O*F)+16;X=m.subarray(W,W+fe),W+=fe}else X=m;const ue=Math.floor(ae/o)*o;if(ue===0)throw new Error("RS parameters too large");const _=ue*i/o,C=Math.ceil(X.length/_)*_;let he=X;if(C>X.length){const j=new Uint8Array(C);j.set(X),he=j}const Z=window.erasure.split(he,i,a/2,ae);if(Z.length!==o)throw new Error("RS split returned unexpected number of fragments");O===0&&(de=Z[0].length);for(let j=0;j<Z.length;j++){const fe=Z[j],ve=new Uint8Array(4);new DataView(ve.buffer).setUint32(0,fe.length,!1),M[j].push(ve,fe)}}const E=[],S=[];for(let O=0;O<o;O++){const X=new Blob(M[O]),ue=new Uint8Array(await X.arrayBuffer());E.push(ue),S.push(await z(ue))}const T=new Date().toISOString(),K={containerId:k,alg:{KEM:"ML-KEM-1024",KDF:"KMAC256",AEAD:"AES-256-GCM",RS:"ErasureCodes",fmt:r},aead_mode:H?"per-chunk":"single-container",iv_strategy:x.iv_strategy,n:o,k:i,m:a,t:B,rsEncodeBase:ae,chunkSize:F,chunkCount:V,containerHash:v,encapBlobHash:await z(l),privateKeyHash:await z(t),payloadLength:x.payloadLength||null,originalLength:$,ciphertextLength:m.length,domainStrings:{kdf:w.kdf,iv:w.iv},fragmentFormat:"len32-prefixed",perFragmentSize:de,hasKeyCommitment:!!f,keyCommitmentHex:f?wt(f):null,shareCommitments:N,fragmentBodyHashes:S,timestamp:T},R=new TextEncoder().encode(JSON.stringify(K)),q=new Uint8Array(2);new DataView(q.buffer).setUint16(0,R.length,!1);const G=new Uint8Array(4);new DataView(G.buffer).setUint32(0,l.length,!1);const Q=new TextEncoder().encode("QVC1"),D=f||new Uint8Array(0),ne=new Uint8Array([D.length]),ce=[];for(let O=0;O<o;O++){const X=E[O],ue=new Uint8Array(2);new DataView(ue.buffer).setUint16(0,y.length,!1);const _=new Uint8Array(Q.length+2+R.length+4+l.length+12+16+2+y.length+1+D.length+2+2+I[O].length);let C=0;_.set(Q,C),C+=Q.length,_.set(q,C),C+=2,_.set(R,C),C+=R.length,_.set(G,C),C+=4,_.set(l,C),C+=l.length,_.set(u,C),C+=12,_.set(h,C),C+=16,_.set(ue,C),C+=2,_.set(y,C),C+=y.length,_.set(ne,C),C+=1,D.length>0&&(_.set(D,C),C+=D.length);const he=new Uint8Array(2);new DataView(he.buffer).setUint16(0,O,!1),_.set(he,C),C+=2;const Z=new Uint8Array(2);new DataView(Z.buffer).setUint16(0,I[O].length,!1),_.set(Z,C),C+=2,_.set(I[O],C);const j=new Blob([_,X],{type:"application/octet-stream"});ce.push({blob:j,index:O})}return ce}function Wr(){const e=document.getElementById("qencForQcontInput"),t=document.getElementById("privKeyForQcontInput"),n=document.getElementById("rsN"),s=document.getElementById("rsK");document.getElementById("buildQcontBtn")?.addEventListener("click",async()=>{if(!e?.files?.[0]){P("Select .qenc");return}if(!t?.files?.[0]){P("Select private .qkey to split");return}const o=t.files[0];if(o.size!==3168){P(`Private .qkey must be exactly 3168 bytes (got ${o.size} B)`);return}oe(!0);try{const i=await ee(e.files[0]),a=await ee(t.files[0]),c=parseInt(n.value,10),d=parseInt(s.value,10);if(Number.isNaN(c)||Number.isNaN(d))throw new Error("Invalid parameters");if(d<2||c<=d)throw new Error("Require 2 <= k < n");if((c-d)%2!==0)throw new Error("(n - k) must be even");if(!bt(c,d))throw new Error("Invalid RS parameters: require nâ‰¥5, 2â‰¤k<n, and (n-k) even");const l=d+(c-d)/2;g(`Building .qcont shards with n=${c}, k=${d}, m=${c-d} (t=${l}), chunkSize=8 MiB ...`);const u=await Bn(i,a,{n:c,k:d}),h=e.files[0].name.replace(/\.qenc$/i,"");u.forEach(({blob:y,index:L})=>{const U=`${h}.part${L+1}-of-${u.length}.qcont`;se(y,U),g(`Saved ${U} (${y.size} B)`)}),g(".qcont shards built. Distribute files across storage providers.")}catch(i){P(i)}finally{oe(!1)}})}const Zr="QVC1",es=32;function ts(e){const t=e.reduce((r,o)=>r+o.length,0),n=new Uint8Array(t);let s=0;for(const r of e)n.set(r,s),s+=r.length;return wt(Ee(n))}function ns(e){if(!(e instanceof Uint8Array))throw new Error("Shard must be a Uint8Array");if(e.length<45)throw new Error("Shard is too small to contain a valid header");const t=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;const s=(b,I)=>{if(n+b>e.length)throw new Error(`Shard is truncated: ${I}`)},r=b=>{s(2,b);const I=t.getUint16(n,!1);return n+=2,I},o=b=>{s(4,b);const I=t.getUint32(n,!1);return n+=4,I},i=(b,I)=>{s(b,I);const N=e.subarray(n,n+b);return n+=b,N};if(new TextDecoder().decode(i(4,"magic"))!==Zr)throw new Error("Invalid .qcont magic");const c=r("metaLen");if(c<=0)throw new Error("Invalid shard metadata length");const d=i(c,"metaJSON");let l;try{l=JSON.parse(new TextDecoder().decode(d))}catch(b){throw new Error(`Invalid shard metadata JSON: ${b?.message||b}`)}if(l?.alg?.fmt!==Ue)throw new Error(`Unsupported shard format: expected ${Ue}, got ${l?.alg?.fmt??"unknown"}`);const u=o("encapsulatedKey length");if(u<=0)throw new Error("Invalid encapsulated key length");const h=i(u,"encapsulatedKey"),y=i(12,"container nonce"),L=i(16,"kdf salt"),U=r("qenc metadata length");if(U<=0)throw new Error("Invalid qenc metadata length");const x=i(U,"qenc metadata"),f=i(1,"key commitment length")[0];if(f>es)throw new Error(`Invalid key commitment length: ${f}`);const m=f>0?i(f,"key commitment"):null,w=r("shard index"),$=r("share length");if($<=0)throw new Error("Invalid Shamir share length");const k=i($,"Shamir share"),v=e.subarray(n),B=ts([d,h,y,L,x,m||new Uint8Array(0)]);return{metaJSON:l,metaBytes:d,encapsulatedKey:h,iv:y,salt:L,qencMetaBytes:x,keyCommit:m,shardIndex:w,share:k,fragments:v,headerFingerprint:B,diagnostics:{errors:[],warnings:[]}}}function xn(e,t={}){const{strict:n=!0}=t;try{return ns(e)}catch(s){if(n)throw s;return{diagnostics:{errors:[s?.message||String(s)],warnings:[]}}}}async function $n(e,t={}){const n=t.onLog||(()=>{}),s=t.onError||(()=>{}),r=t.strict??!0,o=t.consensusRequired??!0;if(!Array.isArray(e)||e.length===0)throw new Error("No shards provided");const i=[];for(let p=0;p<e.length;p++){const A=e[p];if(A?.diagnostics?.errors?.length){if(r)throw new Error(`Shard parse failed at input index ${p}: ${A.diagnostics.errors.join("; ")}`);continue}i.push({...A,inputOrder:p,inputShardIndex:Number.isInteger(A?.shardIndex)?A.shardIndex:p})}if(i.length===0)throw new Error("No valid shards after parsing");let a=i,c=null;const d=[];if(o){const p=new Map;for(const J of i){const le=J.headerFingerprint;if(typeof le!="string"||le.length===0){if(r)throw new Error("Shard is missing header fingerprint");d.push(J.inputShardIndex);continue}p.has(le)||p.set(le,[]),p.get(le).push(J)}if(p.size===0)throw new Error("No valid shard cohort found");let A=null,re=null;for(const[J,le]of p.entries())(!re||le.length>re.length)&&(A=J,re=le);a=re;for(const J of i)J.headerFingerprint!==A&&d.push(J.inputShardIndex);c={consensusRequired:!0,fingerprint:A,totalInput:i.length,cohortSize:a.length,rejectedCount:d.length},n(`Header consensus selected ${a.length}/${i.length} shard(s).`)}if(new Set(a.map(p=>p.metaJSON?.containerId)).size!==1)throw new Error("Selected shards belong to different containers (containerId mismatch)");const u=a[0].metaJSON.containerId,{n:h,k:y,m:L,t:U,ciphertextLength:x,chunkSize:f,chunkCount:m,containerHash:w,privateKeyHash:$,aead_mode:k}=a[0].metaJSON,v=Number.isInteger(a[0].metaJSON.rsEncodeBase)?a[0].metaJSON.rsEncodeBase:255;if(L%2!==0)throw new Error("Invalid shard parameters: n - k must be even");const B=L/2,b=y+B;if(U!==b)throw new Error(`Shard threshold mismatch: meta t=${U}, expected t=${b} from n/k`);const I=k==="per-chunk";if(!I&&k!=="single-container")throw new Error(`Unsupported shard AEAD mode: ${k??"unknown"}`);const N=a[0].metaJSON.payloadLength||a[0].metaJSON.originalLength;for(const p of a){const A=p.metaJSON;if(A.containerId!==u||A.n!==h||A.k!==y||A.m!==L||A.t!==b||A.ciphertextLength!==x||A.chunkCount!==m||A.chunkSize!==f)throw new Error("Shard parameter mismatch (containerId/n/k/m/t)")}const M=new Map,F=a[0],H=F.keyCommit||new Uint8Array(0);for(const p of a){if(!Number.isInteger(p.shardIndex)||p.shardIndex<0||p.shardIndex>=h)throw new Error(`Invalid shardIndex ${p.shardIndex}`);if(M.has(p.shardIndex))throw new Error(`Duplicate shardIndex ${p.shardIndex} detected`);if(M.set(p.shardIndex,p),!Ae(p.encapsulatedKey,F.encapsulatedKey))throw new Error(`Shard header mismatch: encapsulatedKey differs for shard ${p.shardIndex}`);if(!Ae(p.iv,F.iv))throw new Error(`Shard header mismatch: iv differs for shard ${p.shardIndex}`);if(!Ae(p.salt,F.salt))throw new Error(`Shard header mismatch: salt differs for shard ${p.shardIndex}`);if(!Ae(p.qencMetaBytes,F.qencMetaBytes))throw new Error(`Shard header mismatch: qenc metadata differs for shard ${p.shardIndex}`);const A=p.keyCommit||new Uint8Array(0);if(!Ae(A,H))throw new Error(`Shard header mismatch: key commitment differs for shard ${p.shardIndex}`)}const V=new Set;for(let p=0;p<h;p++)M.has(p)||V.add(p);if(await z(a[0].encapsulatedKey)!==a[0].metaJSON.encapBlobHash)throw new Error("encapBlobHash mismatch");if(a.length<b)throw new Error(`Need at least ${b} shards, got ${a.length}`);let W=a;if(a[0].metaJSON.shareCommitments){W=[];const p=new Set;for(const A of a){const re=a[0].metaJSON.shareCommitments[A.shardIndex];if(re){if(await z(A.share)!==re){s(`Share commitment verification failed for shard ${A.shardIndex}. Share will be skipped.`),p.add(A.shardIndex);continue}W.push(A)}else s(`Missing share commitment for shard ${A.shardIndex}. Share will be skipped.`),p.add(A.shardIndex)}if(W.length<b)throw new Error(`Not enough valid shards for Shamir reconstruction: need ${b}, have ${W.length}`);p.size===0?n("Share commitments verified."):s(`Share commitments failed for ${p.size} shard(s). Proceeding with valid shares.`)}const de=new Set;if(a[0].metaJSON.fragmentBodyHashes){for(const p of a){const A=a[0].metaJSON.fragmentBodyHashes[p.shardIndex];A&&await z(p.fragments)!==A&&(s(`Fragment integrity check failed for shard ${p.shardIndex}. Treating as erasure.`),de.add(p.shardIndex))}de.size===0&&n("Fragment body hashes verified.")}const S=V.size+de.size;if(S>B)throw new Error(`Too many missing/corrupted shards for RS reconstruction: allowed ${B}, got ${S}`);const K=W.slice().sort((p,A)=>p.shardIndex-A.shardIndex).slice(0,b).map(p=>p.share),{combineShares:R}=await Ln(async()=>{const{combineShares:p}=await import("./sss-CX0r5NR3.js");return{combineShares:p}},[]),q=await R(K),G=x,Q=m,D=[],ne=new Array(h).fill(0);for(let p=0;p<Q;p++){const A=Math.min(f,N-p*f),re=I?A+16:G,J=Math.floor(v/h)*h;if(J===0)throw new Error("RS parameters too large");const le=J*y/h,Mn=le/y,Ne=Math.ceil(re/le)*Mn,rt=new Array(h);for(let ye=0;ye<h;ye++){const kt=M.get(ye),Te=kt&&!de.has(ye)?kt.fragments:null;if(!Te){rt[ye]=new Uint8Array(Ne);continue}const St=Te.length,st=ne[ye];if(st+4>St)throw new Error("Fragment stream underflow");const ot=new DataView(Te.buffer,Te.byteOffset+st).getUint32(0,!1),Lt=st+4,it=Lt+ot;if(it>St)throw new Error("Fragment length overflow");let Ke=Te.subarray(Lt,it);if(ot<Ne){const Bt=new Uint8Array(Ne);Bt.set(Ke),Ke=Bt}else ot>Ne&&(Ke=Ke.subarray(0,Ne));rt[ye]=Ke,ne[ye]=it}let It;try{It=window.erasure.recombine(rt,re,y,L/2,v)}catch(ye){throw new Error(`RS recombination failed on chunk ${p}: ${ye?.message??ye}`)}if(D.push(It),!I)break}for(let p=0;p<h;p++){if(de.has(p))continue;const A=M.get(p);if(A&&ne[p]!==A.fragments.length)throw new Error(`Fragment stream has trailing or missing data in shard ${p}`)}const ce=I?(()=>{const p=D.reduce((J,le)=>J+le.length,0),A=new Uint8Array(p);let re=0;for(const J of D)A.set(J,re),re+=J.length;return A})():D[0],{encapsulatedKey:O,iv:X,salt:ue,qencMetaBytes:_,keyCommit:C}=a[0];if(a[0].metaJSON?.hasKeyCommitment&&(!C||C.length===0))throw new Error("Missing key commitment in shard data (expected by metadata).");const he=pn({encapsulatedKey:O,containerNonce:X,kdfSalt:ue,metaBytes:_,keyCommitment:C&&C.length>0?C:null}),Z=new Uint8Array(he.length+ce.length);Z.set(he,0),Z.set(ce,he.length);const j=await z(Z),fe=await z(q);return{qencBytes:Z,privKey:q,containerId:u,containerHash:w,privateKeyHash:$,recoveredQencHash:j,recoveredPrivHash:fe,rejectedShardIndices:d,consensusInfo:c,qencOk:j===w,qkeyOk:fe===$}}function rs(){const e=document.getElementById("qcontShardsInput");document.getElementById("restoreQcontBtn")?.addEventListener("click",async()=>{const n=e?.files;if(!n?.length){P("Select .qcont shards");return}if(n.length<2){P("Select at least two .qcont shards");return}const s=n[0].size;for(let r=1;r<n.length;r++)if(n[r].size!==s){P("All selected .qcont shards must have the same file size.");return}oe(!0);try{const o=(await Promise.all([...n].map(ee))).map(xn),i=await $n(o,{onLog:$=>g($),onError:$=>P($)}),{qencBytes:a,privKey:c,containerId:d,containerHash:l,privateKeyHash:u,recoveredQencHash:h,recoveredPrivHash:y,qencOk:L,qkeyOk:U}=i;g(`Recovered .qenc SHA3-512=${h} (expected ${l})`),g(L?"Hashes match! File integrity verified.":"WARNING: .qenc hash mismatch!"),g(`Recovered .qkey SHA3-512=${y} (expected ${u})`),g(U?"Hashes match! File integrity verified.":"WARNING: .qkey hash mismatch!");const x=new Blob([a],{type:"application/octet-stream"}),f=new Blob([c],{type:"application/octet-stream"}),m=`${d}.recovered.qenc`,w=`${d}.recovered.secretKey.qkey`;if(L&&U)se(x,m),se(f,w),g("âœ… Recovered .qenc and .qkey from .qcont shards.");else{P("Hash mismatch detected. Automatic download is blocked. Review and download manually if needed.");const $=document.getElementById("log"),k=document.createElement("a");k.href=URL.createObjectURL(x),k.download=m,k.textContent=`Manual download: ${m}`,k.target="_blank",k.rel="noopener";const v=document.createElement("a");v.href=URL.createObjectURL(f),v.download=w,v.textContent=`Manual download: ${w}`,v.target="_blank",v.rel="noopener",$.appendChild(k),$.appendChild(document.createTextNode(`
`)),$.appendChild(v),$.appendChild(document.createTextNode(`
`))}}catch(r){P(r)}finally{oe(!1)}})}let pe=null,Ve=!0,ft=new Map,Dt=0,et=!0;function nt(e,t){if(e<5)return{error:"Total shards must be at least 5 (configurations with nâ‰¤4 are unstable)"};if(!Number.isFinite(t))return{error:"Invalid threshold percent"};const n=Math.ceil(t/100*e);let s=null,r=null;for(let i=2;i<e;i++){if(!bt(e,i))continue;const a=e-i,c=dn(e,i);if(!Number.isInteger(c))continue;const d=Math.round(c/e*100),l={n:e,k:i,m:a,t:c,actualThresholdPercent:d};c>=n?(!s||c<s.t)&&(s=l):(!r||c>r.t)&&(r=l)}const o=s||r;return o?{n:o.n,k:o.k,m:o.m,t:o.t,actualThresholdPercent:o.actualThresholdPercent}:{error:"Cannot find valid configuration - try adjusting total shards or threshold"}}function ss(e){const t=new Map;for(let n=2;n<e;n++){if(!bt(e,n))continue;const s=e-n,r=dn(e,n);if(!Number.isInteger(r))continue;const o=Math.round(r/e*100);t.set(o,{n:e,k:n,m:s,t:r,actualThresholdPercent:o})}return[...t.values()].sort((n,s)=>n.actualThresholdPercent-s.actualThresholdPercent)}function os(e,t,n=2){const s=[];for(let r=5;r<=25;r++){if(r===t)continue;const o=nt(r,e);o.error||s.push({n:r,actualThresholdPercent:o.actualThresholdPercent,diff:Math.abs(o.actualThresholdPercent-e)})}return s.sort((r,o)=>r.diff-o.diff||r.n-o.n),s.slice(0,n)}function lt(){const e=document.getElementById("liteN"),t=document.getElementById("liteThreshold"),n=document.getElementById("thresholdText"),s=document.getElementById("thresholdDelta"),r=document.getElementById("thresholdHint");if(!e||!t||!n)return;const o=parseInt(e.value,10),i=parseInt(t.value,10);if(s&&(s.textContent="",s.className="threshold-delta"),r&&(r.textContent="Discrete by RS/SSS constraints.",r.className="info-text"),isNaN(o)||isNaN(i)||o<5){n.textContent="Invalid parameters",r&&(r.className="info-text error",r.textContent="Total shards must be at least 5 (n >= 5) to compute a recoverable threshold."),Ce();return}const a=nt(o,i);if(a.error){n.textContent="Configuration Error",r&&(r.className="info-text error",r.textContent=`Adjust parameters to a recoverable configuration: ${a.error}`),Ce();return}const c=a.actualThresholdPercent-i;if(n.textContent=`Requested ${i}% -> Achievable ${a.actualThresholdPercent}% (>=${a.t}/${a.n} shards)`,s)if(c===0)s.className="threshold-delta success",s.textContent="Exact match";else{const d=c>0?"+":"";s.className="threshold-delta warning",s.textContent=`${d}${c} pp`}if(r){const l=ss(o).map(u=>`${u.actualThresholdPercent}%`).join(", ");if(c!==0){const u=os(i,o,2),h=u.length?` Try n=${u[0].n} (${u[0].actualThresholdPercent}%)${u[1]?` or n=${u[1].n} (${u[1].actualThresholdPercent}%)`:""}.`:"";r.textContent=`Requested ${i}% is not directly achievable with n=${a.n}. Using nearest recoverable threshold ${a.actualThresholdPercent}% (k=${a.k}, m=${a.m}, t=${a.t}). Achievable thresholds for n=${o}: ${l}.${h}`,r.className="info-text warning"}else r.textContent=`Valid configuration: n=${a.n}, k=${a.k}, m=${a.m}, t=${a.t} (can lose up to ${a.m/2} shards). Achievable thresholds for n=${o}: ${l}.`,r.className="info-text"}Ce()}async function is(){try{const e=document.getElementById("keyStatus"),t=e?.querySelector(".status-text"),n=e?.querySelector(".status-icon");t&&(t.textContent="Generating keys..."),n&&(n.textContent="ðŸ”„");const s=await wn({collectUserEntropy:!1});pe=s;const r=await z(pe.secretKey),o=await z(pe.publicKey);Hr(r,o,s.seedInfo,{isLiteMode:!0}),t&&(t.textContent="Keys ready âœ“"),n&&(n.textContent="ðŸ”‘");const i=document.getElementById("liteFilesInput");i&&(i.disabled=!1);const a=document.getElementById("liteDownloadKeysBtn");a&&(a.style.display="inline-flex"),Ce()}catch(e){P(`Failed to generate keys: ${e.message}`,{isLiteMode:!0});const t=document.getElementById("keyStatus")?.querySelector(".status-text"),n=document.getElementById("keyStatus")?.querySelector(".status-icon");t&&(t.textContent="Key generation failed âœ—"),n&&(n.textContent="âŒ")}}function as(){const e=document.getElementById("liteFilesInput"),t=document.getElementById("liteFilesList");if(!(!e||!t)){if(!e.files||e.files.length===0){t.style.display="none";return}t.innerHTML="";for(const n of e.files){const s=document.createElement("div");s.className="file-item",s.innerHTML=`<span class="file-name">ðŸ“„ ${n.name}</span><span class="file-size">${We(n.size)}</span>`,t.appendChild(s)}t.style.display="block"}}async function mt(){const e=document.getElementById("liteShardsInput"),t=document.getElementById("shardsStatus"),n=document.getElementById("shardsStatusText"),s=document.getElementById("liteRestoreBtn");if(!e||!t||!n)return;const r=[...e.files||[]],o=++Dt;await Sn({files:r,statusDiv:t,statusText:n,actionButton:s,isCurrent:()=>o===Dt})}function Ce(){const e=document.getElementById("liteCreateShardsBtn"),t=document.getElementById("liteFilesInput"),n=document.getElementById("liteN"),s=document.getElementById("liteThreshold");if(!e||!t)return;const r=pe!==null,o=t.files&&t.files.length>0;let i=!1;if(n&&s){const a=parseInt(n.value,10),c=parseInt(s.value,10);!isNaN(a)&&!isNaN(c)&&a>=5&&(i=!nt(a,c).error)}e.disabled=!r||!o||!i}function cs(){if(!pe){P("No keys available to download",{isLiteMode:!0});return}const e=ln();se(new Blob([pe.secretKey]),`quantum-vault-${e}-secretKey.qkey`),setTimeout(()=>{se(new Blob([pe.publicKey]),`quantum-vault-${e}-publicKey.qkey`)},500),g("âœ… Backup keys downloaded",{isLiteMode:!0})}function De(e,t){const n=document.getElementById(e);if(!n)return;n.querySelectorAll(".pipeline-step").forEach(r=>{t===null?r.classList.remove("active"):r.classList.contains(t)?r.classList.add("active"):r.classList.remove("active")})}async function ls(){const e=document.getElementById("liteFilesInput"),t=document.getElementById("liteN"),n=document.getElementById("liteThreshold");if(!e?.files?.length){P("Please select files to encrypt",{isLiteMode:!0});return}if(!pe){P("Keys not ready",{isLiteMode:!0});return}const s=parseInt(t.value,10),r=parseInt(n.value,10);if(isNaN(s)||isNaN(r)){P("Invalid parameters",{isLiteMode:!0});return}oe(!0),De("liteViewProtect","step-lock");try{const o=nt(s,r);if(o.error)throw new Error(o.error);const i=[...e.files],a=i.length>1;let c,d,l;if(a){const{bundleName:x,bundleBytes:f,fileCount:m}=await vn(i);c=f,d=x,l=`${m} files bundle`;const w=i.reduce(($,k)=>$+k.size,0);g(`Bundled ${m} files (${We(w)}) into ${x}`,{isLiteMode:!0})}else{const x=i[0];c=await ee(x),d=x.name,l=x.name}const u=await ht(c,pe.publicKey,d),h=await ee(u),y=await z(h);ft.set(y,d),Dr(l,c.length,y,{isLiteMode:!0}),De("liteViewProtect","step-split");const L=await Bn(h,pe.secretKey,{n:o.n,k:o.k}),U=d.replace(/\.[^/.]+$/,"");L.forEach(({blob:x,index:f})=>{const m=`${U}.part${f+1}-of-${L.length}.qcont`;se(x,m)}),zr(L.length,o,l,{isLiteMode:!0}),a?g("ðŸ›¡ï¸ Files bundled, encrypted, and split into shards",{isLiteMode:!0}):g("ðŸ›¡ï¸ File encrypted and split into shards",{isLiteMode:!0}),g("Distribute shards across different storage locations for security",{isLiteMode:!0})}catch(o){P(`Failed to create shards: ${o.message}`,{isLiteMode:!0})}finally{oe(!1),Ce(),setTimeout(()=>De("liteViewProtect",null),2e3)}}async function ds(){const e=document.getElementById("liteShardsInput");if(!e?.files?.length){P("Please select shard files to restore",{isLiteMode:!0});return}const t=await kn([...e.files||[]]);if(!t.ready){P(t.message||"Selected shards do not meet the recovery threshold",{isLiteMode:!0});return}oe(!0),De("liteViewRestore","step-combine");try{const s=(await Promise.all([...e.files].map(ee))).map(m=>xn(m,{strict:!0})),r=s[0]?.metaJSON?.containerId;_r(e.files.length,r,{isLiteMode:!0});const o=await $n(s,{onLog:m=>g(m,{isLiteMode:!0}),onError:m=>P(m,{isLiteMode:!0})}),{qencBytes:i,privKey:a,containerHash:c,qencOk:d,qkeyOk:l}=o;if(!d||!l){P("Hash verification failed for container",{isLiteMode:!0});return}const{decryptedBlob:u,metadata:h}=await En(i,a),y=await ee(u),L=await z(y);if(!(h.fileHash===L)){P("File integrity check failed - hashes do not match",{isLiteMode:!0});return}let x;if(vt(y)){const m=In(y);for(const w of m)se(new Blob([w.bytes]),w.name);x=`${m.length} files bundle`,g(`ðŸ“¦ Restored ${m.length} files from encrypted bundle`,{isLiteMode:!0})}else{const m=await z(i);let w=ft.get(m);w||(w=ft.get(c)),w||(w=h.originalFilename||`restored-${o.containerId.slice(0,8)}.file`),se(new Blob([y]),w),x=w}const f=h.timestamp||"Unknown";Qr(x,y.length,f,!0,{isLiteMode:!0}),g("ðŸŽ‰ Container restored successfully",{isLiteMode:!0})}catch(n){P(`Restoration failed: ${n?.message??n}`,{isLiteMode:!0})}finally{oe(!1),mt(),setTimeout(()=>De("liteViewRestore",null),2e3)}}function us(){const e=document.getElementById("liteTabProtect"),t=document.getElementById("liteTabRestore"),n=document.getElementById("liteViewProtect"),s=document.getElementById("liteViewRestore");e&&t&&n&&s&&(e.addEventListener("click",()=>{e.classList.add("active"),t.classList.remove("active"),n.style.display="block",s.style.display="none",n.classList.add("active"),s.classList.remove("active")}),t.addEventListener("click",()=>{e.classList.remove("active"),t.classList.add("active"),n.style.display="none",s.style.display="block",n.classList.remove("active"),s.classList.add("active")}))}function An(){const e=document.getElementById("logContainer"),t=document.getElementById("logToggleBtn");!e||!t||(Ve?(t.style.display="inline-flex",e.classList.toggle("collapsed",et),t.textContent=et?"Show Log":"Hide Log"):(e.classList.remove("collapsed"),t.style.display="none"),t.setAttribute("aria-expanded",String(!e.classList.contains("collapsed"))))}function hs(){Ve&&(et=!et,An())}function zt(){const e=document.getElementById("modeToggle"),t=document.getElementById("liteMode"),n=document.getElementById("proMode");!e||!t||!n||(Ve=!e.checked,Ve?(t.style.display="block",n.style.display="none",g("Switched to Lite Mode",{isLiteMode:!0}),pe||is()):(t.style.display="none",n.style.display="block",g("Switched to Pro Mode",{isLiteMode:!1})),An())}function fs(){const e=document.getElementById("modeToggle");e&&e.addEventListener("change",zt);const t=document.getElementById("logToggleBtn");t&&t.addEventListener("click",hs),us();const n=document.getElementById("liteN"),s=document.getElementById("liteThreshold");n&&s&&(n.addEventListener("input",lt),s.addEventListener("input",lt),lt());const r=document.getElementById("liteFilesInput");r&&(r.addEventListener("change",()=>{as(),Ce()}),r.disabled=!0);const o=document.getElementById("liteShardsInput");o&&(o.addEventListener("change",()=>{mt()}),mt());const i=document.getElementById("liteDownloadKeysBtn");i&&i.addEventListener("click",cs);const a=document.getElementById("liteCreateShardsBtn");a&&a.addEventListener("click",ls);const c=document.getElementById("liteRestoreBtn");c&&c.addEventListener("click",ds),Ve=!0,e&&(e.checked=!1),zt(),g("Lite Mode initialized - toggle to switch to Pro mode",{isLiteMode:!0})}function _t(){Gr(),Wr(),rs(),fs(),console.log("Quantum Vault application initialized successfully")}typeof window<"u"&&(document.readyState==="loading"?document.addEventListener("DOMContentLoaded",_t):_t());export{Ln as _};

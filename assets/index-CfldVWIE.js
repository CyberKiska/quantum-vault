(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();const ce=BigInt(2**32-1),Ae=BigInt(32);function We(t,e=!1){return e?{h:Number(t&ce),l:Number(t>>Ae&ce)}:{h:Number(t>>Ae&ce)|0,l:Number(t&ce)|0}}function Ye(t,e=!1){const n=t.length;let s=new Uint32Array(n),r=new Uint32Array(n);for(let o=0;o<n;o++){const{h:c,l:i}=We(t[o],e);[s[o],r[o]]=[c,i]}return[s,r]}const Ze=(t,e,n)=>t<<n|e>>>32-n,Je=(t,e,n)=>e<<n|t>>>32-n,et=(t,e,n)=>e<<n-32|t>>>64-n,tt=(t,e,n)=>t<<n-32|e>>>64-n,z=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function nt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function ne(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function j(t,...e){if(!nt(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function be(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");ne(t.outputLen),ne(t.blockLen)}function W(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Ne(t,e){j(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function _e(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function V(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function de(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function O(t,e){return t<<32-e|t>>>e}const st=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function rt(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}function ot(t){for(let e=0;e<t.length;e++)t[e]=rt(t[e]);return t}const Le=st?t=>t:ot,ct=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",N={_0:48,_9:57,A:65,F:70,a:97,f:102};function Be(t){if(t>=N._0&&t<=N._9)return t-N._0;if(t>=N.A&&t<=N.F)return t-(N.A-10);if(t>=N.a&&t<=N.f)return t-(N.a-10)}function T(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(ct)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const s=new Uint8Array(n);for(let r=0,o=0;r<n;r++,o+=2){const c=Be(t.charCodeAt(o)),i=Be(t.charCodeAt(o+1));if(c===void 0||i===void 0){const a=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}s[r]=c*16+i}return s}function it(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function G(t){return typeof t=="string"&&(t=it(t)),j(t),t}class ge{}function $e(t){const e=s=>t().update(G(s)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function at(t){const e=(s,r)=>t(r).update(G(s)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=s=>t(s),e}function xt(t=32){if(z&&typeof z.getRandomValues=="function")return z.getRandomValues(new Uint8Array(t));if(z&&typeof z.randomBytes=="function")return Uint8Array.from(z.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}const ft=BigInt(0),J=BigInt(1),lt=BigInt(2),ut=BigInt(7),dt=BigInt(256),ht=BigInt(113),Ce=[],ve=[],Fe=[];for(let t=0,e=J,n=1,s=0;t<24;t++){[n,s]=[s,(2*n+3*s)%5],Ce.push(2*(5*s+n)),ve.push((t+1)*(t+2)/2%64);let r=ft;for(let o=0;o<7;o++)e=(e<<J^(e>>ut)*ht)%dt,e&lt&&(r^=J<<(J<<BigInt(o))-J);Fe.push(r)}const Re=Ye(Fe,!0),yt=Re[0],pt=Re[1],Ee=(t,e,n)=>n>32?et(t,e,n):Ze(t,e,n),He=(t,e,n)=>n>32?tt(t,e,n):Je(t,e,n);function bt(t,e=24){const n=new Uint32Array(10);for(let s=24-e;s<24;s++){for(let c=0;c<10;c++)n[c]=t[c]^t[c+10]^t[c+20]^t[c+30]^t[c+40];for(let c=0;c<10;c+=2){const i=(c+8)%10,a=(c+2)%10,x=n[a],l=n[a+1],f=Ee(x,l,1)^n[i],p=He(x,l,1)^n[i+1];for(let g=0;g<50;g+=10)t[c+g]^=f,t[c+g+1]^=p}let r=t[2],o=t[3];for(let c=0;c<24;c++){const i=ve[c],a=Ee(r,o,i),x=He(r,o,i),l=Ce[c];r=t[l],o=t[l+1],t[l]=a,t[l+1]=x}for(let c=0;c<50;c+=10){for(let i=0;i<10;i++)n[i]=t[c+i];for(let i=0;i<10;i++)t[c+i]^=~n[(i+2)%10]&n[(i+4)%10]}t[0]^=yt[s],t[1]^=pt[s]}V(n)}class le extends ge{constructor(e,n,s,r=!1,o=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=e,this.suffix=n,this.outputLen=s,this.enableXOF=r,this.rounds=o,ne(s),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=_e(this.state)}clone(){return this._cloneInto()}keccak(){Le(this.state32),bt(this.state32,this.rounds),Le(this.state32),this.posOut=0,this.pos=0}update(e){W(this),e=G(e),j(e);const{blockLen:n,state:s}=this,r=e.length;for(let o=0;o<r;){const c=Math.min(n-this.pos,r-o);for(let i=0;i<c;i++)s[this.pos++]^=e[o++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:s,blockLen:r}=this;e[s]^=n,(n&128)!==0&&s===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){W(this,!1),j(e),this.finish();const n=this.state,{blockLen:s}=this;for(let r=0,o=e.length;r<o;){this.posOut>=s&&this.keccak();const c=Math.min(s-this.posOut,o-r);e.set(n.subarray(this.posOut,this.posOut+c),r),this.posOut+=c,r+=c}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ne(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Ne(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,V(this.state)}_cloneInto(e){const{blockLen:n,suffix:s,outputLen:r,rounds:o,enableXOF:c}=this;return e||(e=new le(n,s,r,c,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=s,e.outputLen=r,e.enableXOF=c,e.destroyed=this.destroyed,e}}const qe=(t,e,n)=>$e(()=>new le(e,t,n)),gt=qe(6,136,256/8),Pe=qe(6,72,512/8),De=(t,e,n)=>at((s={})=>new le(e,t,s.dkLen===void 0?n:s.dkLen,!0)),mt=De(31,168,128/8),Me=De(31,136,256/8);function wt(t,e,n,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,s);const r=BigInt(32),o=BigInt(4294967295),c=Number(n>>r&o),i=Number(n&o),a=s?4:0,x=s?0:4;t.setUint32(e+a,c,s),t.setUint32(e+x,i,s)}function At(t,e,n){return t&e^~t&n}function Lt(t,e,n){return t&e^t&n^e&n}class Bt extends ge{constructor(e,n,s,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=n,this.padOffset=s,this.isLE=r,this.buffer=new Uint8Array(e),this.view=de(this.buffer)}update(e){W(this),e=G(e),j(e);const{view:n,buffer:s,blockLen:r}=this,o=e.length;for(let c=0;c<o;){const i=Math.min(r-this.pos,o-c);if(i===r){const a=de(e);for(;r<=o-c;c+=r)this.process(a,c);continue}s.set(e.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){W(this),Ne(e,this),this.finished=!0;const{buffer:n,view:s,blockLen:r,isLE:o}=this;let{pos:c}=this;n[c++]=128,V(this.buffer.subarray(c)),this.padOffset>r-c&&(this.process(s,0),c=0);for(let f=c;f<r;f++)n[f]=0;wt(s,r-8,BigInt(this.length*8),o),this.process(s,0);const i=de(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const x=a/4,l=this.get();if(x>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<x;f++)i.setUint32(4*f,l[f],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const s=e.slice(0,n);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:s,length:r,finished:o,destroyed:c,pos:i}=this;return e.destroyed=c,e.finished=o,e.length=r,e.pos=i,r%n&&e.buffer.set(s),e}clone(){return this._cloneInto()}}const C=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Et=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),v=new Uint32Array(64);class Ht extends Bt{constructor(e=32){super(64,e,8,!1),this.A=C[0]|0,this.B=C[1]|0,this.C=C[2]|0,this.D=C[3]|0,this.E=C[4]|0,this.F=C[5]|0,this.G=C[6]|0,this.H=C[7]|0}get(){const{A:e,B:n,C:s,D:r,E:o,F:c,G:i,H:a}=this;return[e,n,s,r,o,c,i,a]}set(e,n,s,r,o,c,i,a){this.A=e|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=o|0,this.F=c|0,this.G=i|0,this.H=a|0}process(e,n){for(let f=0;f<16;f++,n+=4)v[f]=e.getUint32(n,!1);for(let f=16;f<64;f++){const p=v[f-15],g=v[f-2],E=O(p,7)^O(p,18)^p>>>3,u=O(g,17)^O(g,19)^g>>>10;v[f]=u+v[f-7]+E+v[f-16]|0}let{A:s,B:r,C:o,D:c,E:i,F:a,G:x,H:l}=this;for(let f=0;f<64;f++){const p=O(i,6)^O(i,11)^O(i,25),g=l+p+At(i,a,x)+Et[f]+v[f]|0,u=(O(s,2)^O(s,13)^O(s,22))+Lt(s,r,o)|0;l=x,x=a,a=i,i=c+g|0,c=o,o=r,r=s,s=g+u|0}s=s+this.A|0,r=r+this.B|0,o=o+this.C|0,c=c+this.D|0,i=i+this.E|0,a=a+this.F|0,x=x+this.G|0,l=l+this.H|0,this.set(s,r,o,c,i,a,x,l)}roundClean(){V(v)}destroy(){this.set(0,0,0,0,0,0,0,0),V(this.buffer)}}const Ut=$e(()=>new Ht);/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */const _=j,Ue=xt;function Ie(t,e){if(t.length!==e.length)return!1;let n=0;for(let s=0;s<t.length;s++)n|=t[s]^e[s];return n===0}function ae(...t){const e=s=>typeof s=="number"?s:s.bytesLen,n=t.reduce((s,r)=>s+e(r),0);return{bytesLen:n,encode:s=>{const r=new Uint8Array(n);for(let o=0,c=0;o<t.length;o++){const i=t[o],a=e(i),x=typeof i=="number"?s[o]:i.encode(s[o]);_(x,a),r.set(x,c),typeof i!="number"&&x.fill(0),c+=a}return r},decode:s=>{_(s,n);const r=[];for(const o of t){const c=e(o),i=s.subarray(0,c);r.push(typeof o=="number"?i:o.decode(i)),s=s.subarray(c)}return r}}}function he(t,e){const n=e*t.bytesLen;return{bytesLen:n,encode:s=>{if(s.length!==e)throw new Error(`vecCoder.encode: wrong length=${s.length}. Expected: ${e}`);const r=new Uint8Array(n);for(let o=0,c=0;o<s.length;o++){const i=t.encode(s[o]);r.set(i,c),i.fill(0),c+=i.length}return r},decode:s=>{_(s,n);const r=[];for(let o=0;o<s.length;o+=t.bytesLen)r.push(t.decode(s.subarray(o,o+t.bytesLen)));return r}}}function D(...t){for(const e of t)if(Array.isArray(e))for(const n of e)n.fill(0);else e.fill(0)}function ke(t){return(1<<t)-1}T("0609608648016503040201"),T("0609608648016503040202"),T("0609608648016503040203"),T("0609608648016503040204"),T("0609608648016503040205"),T("0609608648016503040206"),T("0609608648016503040207"),T("0609608648016503040208"),T("0609608648016503040209"),T("060960864801650304020A"),T("060960864801650304020B"),T("060960864801650304020C");/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */function It(t,e=8){const r=t.toString(2).padStart(8,"0").slice(-e).padStart(7,"0").split("").reverse().join("");return Number.parseInt(r,2)}const kt=t=>{const{newPoly:e,N:n,Q:s,F:r,ROOT_OF_UNITY:o,brvBits:c}=t,i=(u,h=s)=>{const d=u%h|0;return(d>=0?d|0:h+d|0)|0},a=(u,h=s)=>{const d=i(u,h)|0;return(d>h>>1?d-h|0:d)|0};function x(){const u=e(n);for(let h=0;h<n;h++){const d=It(h,c),m=BigInt(o)**BigInt(d)%BigInt(s);u[h]=Number(m)|0}return u}const l=x(),f=128,p=1;return{mod:i,smod:a,nttZetas:l,NTT:{encode:u=>{for(let h=1,d=128;d>p;d>>=1)for(let m=0;m<n;m+=2*d){const w=l[h++];for(let y=m;y<m+d;y++){const b=i(w*u[y+d]);u[y+d]=i(u[y]-b)|0,u[y]=i(u[y]+b)|0}}return u},decode:u=>{for(let h=f-1,d=1+p;d<f+p;d<<=1)for(let m=0;m<n;m+=2*d){const w=l[h--];for(let y=m;y<m+d;y++){const b=u[y];u[y]=i(b+u[y+d]),u[y+d]=i(w*(u[y+d]-b))}}for(let h=0;h<u.length;h++)u[h]=i(r*u[h]);return u}},bitsCoder:(u,h)=>{const d=ke(u),m=u*(n/8);return{bytesLen:m,encode:w=>{const y=new Uint8Array(m);for(let b=0,A=0,B=0,$=0;b<w.length;b++)for(A|=(h.encode(w[b])&d)<<B,B+=u;B>=8;B-=8,A>>=8)y[$++]=A&ke(B);return y},decode:w=>{const y=e(n);for(let b=0,A=0,B=0,$=0;b<w.length;b++)for(A|=w[b]<<B,B+=8;B>=u;B-=u,A>>=u)y[$++]=h.decode(A&d);return y}}}}},Tt=t=>(e,n)=>{n||(n=t.blockLen);const s=new Uint8Array(e.length+2);s.set(e);const r=e.length,o=new Uint8Array(n);let c=t.create({}),i=0,a=0;return{stats:()=>({calls:i,xofs:a}),get:(x,l)=>(s[r+0]=x,s[r+1]=l,c.destroy(),c=t.create({}).update(s),i++,()=>(a++,c.xofInto(o))),clean:()=>{c.destroy(),o.fill(0),s.fill(0)}}},St=Tt(mt);/*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) */const U=256,M=3329,Ot=3303,Kt=17,{mod:se,nttZetas:Nt,NTT:q,bitsCoder:_t}=kt({N:U,Q:M,F:Ot,ROOT_OF_UNITY:Kt,newPoly:t=>new Uint16Array(t),brvBits:7}),$t={1024:{N:U,Q:M,K:4,ETA1:2,ETA2:2,du:11,dv:5,RBGstrength:256}},Ct=t=>{if(t>=12)return{encode:n=>n,decode:n=>n};const e=2**(t-1);return{encode:n=>((n<<t)+M/2)/M,decode:n=>n*M+e>>>t}},ee=t=>_t(t,Ct(t));function P(t,e){for(let n=0;n<U;n++)t[n]=se(t[n]+e[n])}function vt(t,e){for(let n=0;n<U;n++)t[n]=se(t[n]-e[n])}function Ft(t,e,n,s,r){const o=se(e*s*r+t*n),c=se(t*s+e*n);return{c0:o,c1:c}}function ie(t,e){for(let n=0;n<U/2;n++){let s=Nt[64+(n>>1)];n&1&&(s=-s);const{c0:r,c1:o}=Ft(t[2*n+0],t[2*n+1],e[2*n+0],e[2*n+1],s);t[2*n+0]=r,t[2*n+1]=o}return t}function Te(t){const e=new Uint16Array(U);for(let n=0;n<U;){const s=t();if(s.length%3)throw new Error("SampleNTT: unaligned block");for(let r=0;n<U&&r+3<=s.length;r+=3){const o=(s[r+0]>>0|s[r+1]<<8)&4095,c=(s[r+1]>>4|s[r+2]<<4)&4095;o<M&&(e[n++]=o),n<U&&c<M&&(e[n++]=c)}}return e}function te(t,e,n,s){const r=t(s*U/4,e,n),o=new Uint16Array(U),c=_e(r);let i=0;for(let a=0,x=0,l=0,f=0;a<c.length;a++){let p=c[a];for(let g=0;g<32;g++)l+=p&1,p>>=1,i+=1,i===s?(f=l,l=0):i===2*s&&(o[x++]=se(f-l),l=0,i=0)}if(i)throw new Error(`sampleCBD: leftover bits: ${i}`);return o}const Rt=t=>{const{K:e,PRF:n,XOF:s,HASH512:r,ETA1:o,ETA2:c,du:i,dv:a}=t,x=ee(1),l=ee(a),f=ee(i),p=ae(he(ee(12),e),32),g=he(ee(12),e),E=ae(he(f,e),l),u=ae(32,32);return{secretCoder:g,secretKeyLen:g.bytesLen,publicKeyLen:p.bytesLen,cipherTextLen:E.bytesLen,keygen:h=>{_(h,32);const d=new Uint8Array(33);d.set(h),d[32]=e;const m=r(d),[w,y]=u.decode(m),b=[],A=[];for(let k=0;k<e;k++)b.push(q.encode(te(n,y,k,o)));const B=s(w);for(let k=0;k<e;k++){const Z=q.encode(te(n,y,e+k,o));for(let H=0;H<e;H++){const re=Te(B.get(H,k));P(Z,ie(re,b[H]))}A.push(Z)}B.clean();const $={publicKey:p.encode([A,w]),secretKey:g.encode(b)};return D(w,y,b,A,d,m),$},encrypt:(h,d,m)=>{const[w,y]=p.decode(h),b=[];for(let H=0;H<e;H++)b.push(q.encode(te(n,m,H,o)));const A=s(y),B=new Uint16Array(U),$=[];for(let H=0;H<e;H++){const re=te(n,m,e+H,c),ue=new Uint16Array(U);for(let oe=0;oe<e;oe++){const Qe=Te(A.get(H,oe));P(ue,ie(Qe,b[oe]))}P(re,q.decode(ue)),$.push(re),P(B,ie(w[H],b[H])),ue.fill(0)}A.clean();const k=te(n,m,2*e,c);P(k,q.decode(B));const Z=x.decode(d);return P(Z,k),D(w,b,B,k),E.encode([$,Z])},decrypt:(h,d)=>{const[m,w]=E.decode(h),y=g.decode(d),b=new Uint16Array(U);for(let A=0;A<e;A++)P(b,ie(y[A],q.encode(m[A])));return vt(w,q.decode(b)),D(b,y,m),x.encode(w)}}};function qt(t){const e=Rt(t),{HASH256:n,HASH512:s,KDF:r}=t,{secretCoder:o,cipherTextLen:c}=e,i=e.publicKeyLen,a=ae(e.secretKeyLen,e.publicKeyLen,32,32),x=a.bytesLen,l=32;return{publicKeyLen:i,msgLen:l,keygen:(f=Ue(64))=>{_(f,64);const{publicKey:p,secretKey:g}=e.keygen(f.subarray(0,32)),E=n(p),u=a.encode([g,p,E,f.subarray(32)]);return D(g,E),{publicKey:p,secretKey:u}},encapsulate:(f,p=Ue(32))=>{_(f,i),_(p,l);const g=f.subarray(0,384*t.K),E=o.encode(o.decode(g.slice()));if(!Ie(E,g))throw D(E),new Error("ML-KEM.encapsulate: wrong publicKey modulus");D(E);const u=s.create().update(p).update(n(f)).digest(),h=e.encrypt(f,p,u.subarray(32,64));return u.subarray(32).fill(0),{cipherText:h,sharedSecret:u.subarray(0,32)}},decapsulate:(f,p)=>{_(p,x),_(f,c);const[g,E,u,h]=a.decode(p),d=e.decrypt(f,g),m=s.create().update(d).update(u).digest(),w=m.subarray(0,32),y=e.encrypt(E,d,m.subarray(32,64)),b=Ie(f,y),A=r.create({dkLen:32}).update(h).update(f).digest();return D(d,y,b?A:w),b?w:A}}}function Pt(t,e,n){return Me.create({dkLen:t}).update(e).update(new Uint8Array([n])).digest()}const Dt={HASH256:gt,HASH512:Pe,KDF:Me,XOF:St,PRF:Pt},me=qt({...Dt,...$t[1024]});class je extends ge{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,be(e);const s=G(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,o=new Uint8Array(r);o.set(s.length>r?e.create().update(s).digest():s);for(let c=0;c<o.length;c++)o[c]^=54;this.iHash.update(o),this.oHash=e.create();for(let c=0;c<o.length;c++)o[c]^=106;this.oHash.update(o),V(o)}update(e){return W(this),this.iHash.update(e),this}digestInto(e){W(this),j(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:s,finished:r,destroyed:o,blockLen:c,outputLen:i}=this;return e=e,e.finished=r,e.destroyed=o,e.blockLen=c,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const we=(t,e,n)=>new je(t,e).update(n).digest();we.create=(t,e)=>new je(t,e);function Mt(t,e,n){return be(t),n===void 0&&(n=new Uint8Array(t.outputLen)),we(t,G(n),G(e))}const ye=Uint8Array.from([0]),Se=Uint8Array.of();function jt(t,e,n,s=32){be(t),ne(s);const r=t.outputLen;if(s>255*r)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(s/r);n===void 0&&(n=Se);const c=new Uint8Array(o*r),i=we.create(t,e),a=i._cloneInto(),x=new Uint8Array(i.outputLen);for(let l=0;l<o;l++)ye[0]=l+1,a.update(l===0?Se:x).update(n).update(ye).digestInto(x),c.set(x,r*l),i._cloneInto(a);return i.destroy(),a.destroy(),V(x,ye),c.slice(0,s)}const Vt=(t,e,n,s,r)=>jt(t,Mt(t,e,n),s,r),Gt=Ut;function Ve(t){return crypto.getRandomValues(new Uint8Array(t))}const fe=new Uint8Array([0,255,200,8,145,16,208,54,90,62,216,67,153,119,254,24,35,32,7,112,161,108,12,127,98,139,64,70,199,75,224,14,235,22,232,173,207,205,57,83,106,39,53,147,212,78,72,195,43,121,84,40,9,120,15,33,144,135,20,42,169,156,214,116,180,124,222,237,177,134,118,164,152,226,150,143,2,50,28,193,51,238,239,129,253,48,92,19,157,41,23,196,17,68,140,128,243,115,66,30,29,181,240,18,209,91,65,162,215,44,233,213,89,203,80,168,220,252,242,86,114,166,101,47,159,155,61,186,125,194,69,130,167,87,182,163,122,117,79,174,63,55,109,71,97,190,171,211,95,176,88,175,202,94,250,133,228,77,138,5,251,96,183,123,184,38,74,103,198,26,248,105,37,179,219,189,102,221,241,210,223,3,141,52,217,146,13,99,85,170,73,236,188,149,60,132,11,245,230,231,229,172,126,110,185,249,218,142,154,201,36,225,10,21,107,58,160,81,244,234,178,151,158,93,34,136,148,206,25,1,113,76,165,227,197,49,187,204,31,45,59,82,111,246,46,137,247,192,104,27,100,4,6,191,131,56]),Ge=new Uint8Array([1,229,76,181,251,159,252,18,3,52,212,196,22,186,31,54,5,92,103,87,58,213,33,90,15,228,169,249,78,100,99,238,17,55,224,16,210,172,165,41,51,89,59,48,109,239,244,123,85,235,77,80,183,42,7,141,255,38,215,240,194,126,9,140,26,106,98,11,93,130,27,143,46,190,166,29,231,157,45,138,114,217,241,39,50,188,119,133,150,112,8,105,86,223,153,148,161,144,24,187,250,122,176,167,248,171,40,214,21,142,203,242,19,230,120,97,63,137,70,13,53,49,136,163,65,128,202,23,95,83,131,254,195,155,69,57,225,245,158,25,94,182,207,75,56,4,185,43,226,193,74,221,72,12,208,125,61,88,222,124,216,20,107,135,71,232,121,132,115,60,189,146,201,35,139,151,149,68,220,173,64,101,134,162,164,204,127,236,192,175,145,253,247,79,129,47,91,234,168,28,2,209,152,113,237,37,227,36,6,104,179,147,44,111,62,108,10,184,206,174,116,177,66,180,30,211,73,233,156,200,198,199,34,110,219,32,191,67,81,82,102,178,118,96,218,197,243,246,170,205,154,160,117,84,14,1]);function xe(t,e){if(!Number.isInteger(t)||t<0||t>255)throw new RangeError("Number is out of Uint8 range");if(!Number.isInteger(e)||e<0||e>255)throw new RangeError("Number is out of Uint8 range");return t^e}function zt(t,e){if(!Number.isInteger(t)||t<0||t>255)throw new RangeError("Number is out of Uint8 range");if(!Number.isInteger(e)||e<0||e>255)throw new RangeError("Number is out of Uint8 range");if(e===0)throw new Error("cannot divide by zero");const n=fe[t],s=fe[e],r=(n-s+255)%255,o=Ge[r];return t===0?0:o}function pe(t,e){if(!Number.isInteger(t)||t<0||t>255)throw new RangeError("Number is out of Uint8 range");if(!Number.isInteger(e)||e<0||e>255)throw new RangeError("Number is out of Uint8 range");const n=fe[t],s=fe[e],r=(n+s)%255,o=Ge[r];return t===0||e===0?0:o}function Xt(t,e,n){if(t.length!==e.length)throw new Error("sample length mistmatch");const s=t.length;let r=0,o=0;for(let c=0;c<s;c++){r=1;for(let i=0;i<s;++i){if(c===i)continue;const a=xe(n,t[i]),x=xe(t[c],t[i]),l=zt(a,x);r=pe(r,l)}o=xe(o,pe(e[c],r))}return o}function Qt(t,e,n){if(e===0)throw new Error("cannot evaluate secret polynomial at zero");let s=t[n];for(let r=n-1;r>=0;r--){const o=t[r];s=xe(pe(s,e),o)}return s}function Wt(t,e){const n=new Uint8Array(e+1);return n[0]=t,n.set(Ve(e),1),n}function Yt(){const t=new Uint8Array(255);for(let n=0;n<255;n++)t[n]=n+1;const e=Ve(255);for(let n=0;n<255;n++){const s=e[n]%255,r=t[n];t[n]=t[s],t[s]=r}return t}const I={instanceOf(t,e,n){if(t.constructor!==e)throw new TypeError(n)},inRange(t,e,n,s){if(!(e<n&&t>=e&&t<n))throw new RangeError(s)},greaterThanOrEqualTo(t,e,n){if(t<e)throw new Error(n)},equalTo(t,e,n){if(t!==e)throw new Error(n)}};async function Zt(t,e,n){I.instanceOf(t,Uint8Array,"secret must be a Uint8Array"),I.greaterThanOrEqualTo(t.byteLength,1,"secret cannot be empty"),I.instanceOf(e,Number,"shares must be a number"),I.inRange(e,2,256,"shares must be at least 2 and at most 255"),I.instanceOf(n,Number,"threshold must be a number"),I.inRange(n,2,256,"threshold must be at least 2 and at most 255"),I.greaterThanOrEqualTo(e,n,"shares cannot be less than threshold");const s=[],r=t.byteLength,o=Yt();for(let i=0;i<e;i++){const a=new Uint8Array(r+1);a[r]=o[i],s.push(a)}const c=n-1;for(let i=0;i<r;i++){const a=t[i],x=Wt(a,c);for(let l=0;l<e;++l){const f=o[l],p=Qt(x,f,c);s[l][i]=p}}return s}async function Jt(t){I.instanceOf(t,Array,"shares must be an Array"),I.inRange(t.length,2,256,"shares must have at least 2 and at most 255 elements");const e=t[0];I.instanceOf(e,Uint8Array,"each share must be a Uint8Array");for(const x of t)I.instanceOf(x,Uint8Array,"each share must be a Uint8Array"),I.greaterThanOrEqualTo(x.byteLength,2,"each share must be at least 2 bytes"),I.equalTo(x.byteLength,e.byteLength,"all shares must have the same byte length");const n=t.length,s=e.byteLength,r=s-1,o=new Uint8Array(r),c=new Uint8Array(n),i=new Uint8Array(n),a=new Set;for(let x=0;x<n;x++){const f=t[x][s-1];if(a.has(f))throw new Error("shares must contain unique values but a duplicate was found");a.add(f),c[x]=f}for(let x=0;x<r;x++){for(let l=0;l<n;++l)i[l]=t[l][x];o[x]=Xt(c,i,0)}return o}const en=document.querySelectorAll("button"),Oe=document.getElementById("privKeyInput"),Ke=document.getElementById("pubKeyInput"),X=document.getElementById("dataFileInput"),tn=document.getElementById("containerToSplitInput"),nn=document.getElementById("shardsToCombineInput"),sn=document.getElementById("shamirShares"),ze=document.getElementById("shamirThreshold"),rn=document.getElementById("genKeyBtn"),on=document.getElementById("encBtn"),cn=document.getElementById("decBtn"),an=document.getElementById("splitBtn"),xn=document.getElementById("combineBtn"),Q=document.getElementById("log"),fn=t=>Array.from(t).map(e=>e.toString(16).padStart(2,"0")).join("");function L(t){Q.textContent+=`[${new Date().toLocaleTimeString()}] ${t}
`,Q.scrollTop=Q.scrollHeight}function S(t){Q.innerHTML+=`<span class="error">[${new Date().toLocaleTimeString()}] ERROR: ${t}</span>
`,Q.scrollTop=Q.scrollHeight}function K(t){en.forEach(e=>e.disabled=t)}function Y(t,e){const n=document.createElement("a");n.href=URL.createObjectURL(t),n.download=e,n.style.display="none",document.body.appendChild(n),n.click(),URL.revokeObjectURL(n.href),n.remove()}async function F(t){return new Uint8Array(await t.arrayBuffer())}async function R(t){return fn(Pe(t))}async function Xe(t,e){const n=Vt(Gt,t,e,new Uint8Array(0),32);return crypto.subtle.importKey("raw",n,"AES-GCM",!1,["encrypt","decrypt"])}async function ln(t,e){const{cipherText:n,sharedSecret:s}=me.encapsulate(e);if(!n)throw new Error("Encapsulation failed. The returned key is undefined.");const r=crypto.getRandomValues(new Uint8Array(12)),o=crypto.getRandomValues(new Uint8Array(16)),c=await Xe(s,o),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:r},c,t),a=new TextEncoder().encode("QGv1"),x=new Uint8Array(4);new DataView(x.buffer).setUint32(0,n.length,!1);const l=new Uint8Array([...a,...x,...n,...r,...o]);return new Blob([l,new Uint8Array(i)],{type:"application/octet-stream"})}async function un(t,e){if(new TextDecoder().decode(t.slice(0,4))!=="QGv1")throw new Error("Invalid file format or file is corrupted.");let s=4;const r=new DataView(t.buffer).getUint32(s,!1);s+=4;const o=t.slice(s,s+r);s+=r;const c=t.slice(s,s+12);s+=12;const i=t.slice(s,s+16);s+=16;const a=t.slice(s),x=me.decapsulate(o,e),l=await Xe(x,i),f=await crypto.subtle.decrypt({name:"AES-GCM",iv:c},l,a);return new Blob([f])}rn.addEventListener("click",async()=>{K(!0);try{L("Generating ML-KEM Kyber 1024 key pair...");const{secretKey:t,publicKey:e}=me.keygen(),n=await R(t),s=await R(e);L(`Private Key: secretKey.qkey (${t.length} B) SHA3-512=${n}`),L(`Public Key: publicKey.qkey (${e.length} B) SHA3-512=${s}`),Y(new Blob([t]),"secretKey.qkey"),Y(new Blob([e]),"publicKey.qkey"),L("✅ Keys generated and downloaded successfully.")}catch(t){S(t.message)}finally{K(!1)}});on.addEventListener("click",async()=>{if(!Ke.files[0]){S("Please select a public key (.qkey).");return}if(!X.files.length){S("Please select file(s) to encrypt.");return}K(!0);try{const t=await F(Ke.files[0]);for(const e of X.files){L(`Encrypting file ${e.name} (${e.size} B)...`);const n=await F(e),s=await R(n);L(`  Source file hash: SHA3-512=${s}`);const r=await ln(n,t),o=await F(r),c=await R(o);Y(r,`${e.name}.qenc`),L(`✅ File encrypted: ${e.name}.qenc (${r.size} B) SHA3-512=${c}`)}}catch(t){S(t.message)}finally{K(!1),X.value=""}});cn.addEventListener("click",async()=>{if(!Oe.files[0]){S("Please select a private key (.qkey).");return}if(!X.files.length){S("Please select file(s) to decrypt (.qenc).");return}K(!0);try{const t=await F(Oe.files[0]);for(const e of X.files){if(!e.name.toLowerCase().endsWith(".qenc")){L(`Skipping file ${e.name} as it is not a .qenc container.`);continue}L(`Decrypting file ${e.name} (${e.size} B)...`);const n=await F(e),s=await R(n);L(`  Container hash: SHA3-512=${s}`);const r=await un(n,t),o=await F(r),c=await R(o),i=e.name.replace(/\.qenc$/i,"");Y(r,i),L(`✅ File decrypted: ${i} (${r.size} B) SHA3-512=${c}`)}}catch(t){S(`Failed to decrypt file. Check if the key is correct. Details: ${t.message}`)}finally{K(!1),X.value=""}});an.addEventListener("click",async()=>{const t=tn.files[0];if(!t){S("Please select a .qenc container to split.");return}K(!0);try{const e=parseInt(sn.value,10),n=parseInt(ze.value,10);if(isNaN(e)||isNaN(n)||n>e||n<2||e<2)throw new Error("Invalid N and T parameters. Ensure T >= 2 and N >= T.");L(`Splitting container ${t.name} into ${e} parts with a threshold of ${n}...`);const s=await F(t),r=await R(s);L(`  Container hash: SHA3-512=${r}`);const o=await Zt(s,e,n),c=Object.values(o),i=t.name.replace(/\.qenc$/i,"");c.forEach((a,x)=>{const l=new Blob([a]),f=`${i}-${x+1}.qshard`;Y(l,f),L(`  ✂️ Shard created: ${f} (${l.size} B)`)}),L("✅ Splitting process completed successfully.")}catch(e){S(e.message)}finally{K(!1)}});xn.addEventListener("click",async()=>{const t=nn.files;if(!t.length){S("Please select .qshard files to combine.");return}K(!0);try{const e=parseInt(ze.value,10);if(t.length<e)throw new Error(`Not enough shards to reconstruct. A minimum of ${e} is required, but ${t.length} were selected.`);L(`Combining container from ${t.length} shards...`);const n=await Promise.all([...t].map(a=>F(a))),s=await Jt(n),r=new Blob([s]),o=await R(s),i=`${t[0].name.replace(/-\d+\.qshard$/i,"")}.qenc`;Y(r,i),L(`✅ Container combined: ${i} (${r.size} B) SHA3-512=${o}`),L("  Compare this hash with the original container hash to verify integrity.")}catch(e){S(`Failed to combine container. Ensure the shards are from the same set and meet the threshold. Details: ${e.message}`)}finally{K(!1)}});
